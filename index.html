<html>

<head>
<!--
	the style is based on the simple example found on w3schools.com:

		https://www.w3schools.com/howto/howto_css_calendar.asp

	internal CSS is used for conveience of the user being able to download
	a single file and open it and "just work"

	if you want to override the style, copy paste this out to style .css and
	add the following line here, and comment out the style element

		<link rel="stylesheet" href="style.css">

	-->
<style>
ul
{
	list-style-type: none;
	padding-inline-start: 0px;
	margin-block-start: 0em;
	margin-block-end: 0em;
	justify-content: center;
}

body
{
	font-family: Verdana, sans-serif;
	font-size: 1.25vw;
}

.title
{
	font-weight: bold;
	font-size: 135%;
}

.test-line
{
	font-size: 75%;
}

.location-choice
{
	width: 10%;
}

.custom-latitude
{
	width: 10%;
}

.custom-longitude
{
	width: 10%;
}

.sopdet-visible-warning
{
	font-size: 85%;
	font-weight: bold;
	color: #a00;
}

.calendar-display
{
	width: 70%;
}

.sidebar
{
	width: 30%;
	height: 100%;
	position: fixed;
	top: 0;
	right: 0;
	padding-top: 40px;
	background-color: #ffffff;
}

.sidebar-today-title
{
	color: #00a;
}

.sidebar-end-of-decan
{
	color: #00a;
}

.sidebar-sopdet-day
{
	color: #00a;
}


.sidebar-title
{
	font-size: 115%;
	font-weight: bold;
}

.sidebar-date-simple
{
	font-size: 95%;
	font-style: italic;
}

.sidebar-day-segment-area
{
	background: #ffffff;
	grid-template-columns: repeat(24, minmax(0,1fr));
	display: grid;
	padding: 0;
	margin: 0;
	align-items: center;
	justify-content: center;
	justify-items: center;
	text-align: center;
	gap: 0;
	width: 100%;
	height: 100px;
	font-size: 40%;
	color: #fff;
}

.sidebar-day-segment-area li
{
	position: relative;
	display: inline-flex;
	background: #113377;
	width: 94%;
	height: 100%;
	vertical-align: baseline;
	align-items: flex-end;
	align-content: center;
	justify-content: center;
}

.sun-marker
{
	width: 90%;
	align-content: center;
	position: absolute;
	/*float: left;*/
	top: 0;
	left: 6%;
}

.months
{
	background: #3adcbc;
	padding: 0% 2%;
	text-align: center;
}

.intercalary
{
	background: #3adcbc;
	padding: 0% 2%;
	text-align: center;
}

.intercalary li
{
	display: inline-block;
	padding: 0.5% 0.5%;
	margin: 1% 1%;
	width: 20%;
	color: #333;
	background: #1abc9c;
	text-align: center;
}

.months li
{
	display: inline-block;
	padding: 0.5% 0.5%;
	margin: 1% 1%;
	width: 21.5%;
	color: #333;
	background: #1abc9c;
	text-align: center;
}

.month-name
{
	font-weight: bold;
	font-size: 95%;
	text-align: center;
}

.month-season-name
{
	font-style: italic;
	text-align: center;
	font-size: 85%;
	padding: 0.3% 0%;
	margin-bottom:1.5%;
}

.month hr
{
	margin-bottom:1%;
	margin-top:0.5%;
}

.days
{
	background: #ffffff;
	grid-template-columns: repeat(10, 1fr);
	display: grid;
	padding: 0;
	margin: 0;
	align-items: center;
	justify-content: center;
	justify-items: center;
	text-align: center;
	gap: 0;
}

.intercalary .days
{
	grid-template-columns: repeat(5, 1fr);
}

.days li
{
	display: inline-flex;
	color: #666;
	background: #ffffff;
	align-items: center;
	justify-content: center;
	text-align: center;
	font-size: 67%;
	border-width: 1.5px;
	border-style: solid;
	border-color: #ffffff;
	width: 100% !important;
}

.intercalary .days li
{
	grid-template-columns: repeat(5, 1fr);
	width: 66% !important;
}

.festival-date
{
	background: #6aeccc !important;
}

.sopdet-heliacal-rising-day
{
	background: #7cf07c !important;
	color: #070 !important;
}

.today-date
{
	background: #ec6c6c !important;
	color: #000 !important;
}

.end-of-decan
{
	background: #f0bcbc !important;
	color: #777 !important;
}

.selected-date
{
	border-color: #59a !important;
}

@media (max-aspect-ratio: 5/3)
{
	body
	{
		font-size: 1.5vw;
	}

	.title
	{
		font-size: 150%;
	}

	.months li
	{
		width:29.5%;
	}

	.intercalary li
	{
		width: 30%;
	}

	.sidebar-day-segment-area
	{
		font-size: 35%;
	}
}

@media (max-aspect-ratio: 6/5)
{
	body
	{
		font-size: 3vw;
	}

	.title
	{
		font-size: 200%;
	}

	.location-choice
	{
		width: 15%;
	}

	.months li
	{
		width:46.5%;
	}

	.intercalary li
	{
		width: 50%;
	}

	.sidebar
	{
		width: 100%;
		height: 10%;
		padding-top: 40px;
		position: relative;
		background-color: #ffffff;
	}

	.calendar-display
	{
		width: 100%;
	}

	.sidebar-day-segment-area
	{
		font-size: 60%;
	}
}

@media (max-aspect-ratio: 5/6)
{
	body
	{
		font-size: 5vw;
	}

	.title
	{
		font-size: 111%;
	}

	.location-choice
	{
		width: 15%;
	}

	.months li
	{
		width:96.5%;
	}

	.intercalary li
	{
		width: 96.5%;
	}

	.sidebar
	{
		width: 100%;
		height: 10%;
		padding-top: 40px;
		position: relative;
		background-color: #ffffff;
	}

	.calendar-display
	{
		width: 100%;
	}

	.sidebar-day-segment-area
	{
		font-size: 40%;
	}
}

@media (prefers-color-scheme: dark)
{
	html
	{
		background: #222;
		color: #ccc;
	}

	.sidebar
	{
		background: #222;
	}

	.months
	{
		background: #333;
	}

	.days
	{
		background: #222;
		color: #aaa;
	}

	.intercalary
	{
		background: #333;
	}

	.months li
	{
		background: #222;
		color: #ccc;
	}

	.intercalary li
	{
		background: #222;
		color: #ccc;
	}

	.festival-date
	{
		background: #224477 !important;
	}

	.sidebar-day-segment-area
	{
		background: #222;
	}
</style>

<title>Kemetic Festival Calendar</title>

</head>

<body>
<span class="title">Kemetic Festival Calendar</span>
<hr>
<div class="options">
	<label for="wep-ronpet">Wep Ronpet Date (Gregorian):</label>
	<input type="date" id="wep-ronpet" name="wep-ronpet">
	<button type="button" onclick='applyChanges();'>Change Date</button>
	<hr>
	<label for="month-names">Month Names:</label>
	<select name="month-names" id="month-names" onchange="updateMonthStyle()">
		<option value="0">Middle Kingdom</option>
		<option value="1">New Kingdom</option>
		<option value="2">Greek</option>
	</select>
	<hr>
	<label for="location-choice">Location:</label>
	<select class="location-choice" name="location-choice" id="location-choice" onchange="applyLocationSelection()">
		<option value="0">Custom</option>
		<option value="1">London, UK - Greenwich Observatory</option>
		<option value="2">Giza, Egypt - Great Pyramid</option>
		<option value="3">New York, USA - Statue of Liberty</option>
		<option value="4">Agra, India - Taj Mahal</option>
		<option value="5">Sydney, Australia - Sydney Opera House</option>
		<option value="6">Rio de Janeiro, Brazil - Christ the Redeemer</option>
	</select>
	<label for="custom-latitude"Latitude:</label>
	<input class="custom-latitude" name="custom-latitude" id="custom-latitude" type="text">
	<label for="custom-longitude"Longitude:</label>
	<input class="custom-longitude" name="custom-longitude" id="custom-longitude" type="text">
	<button type="button" onclick='applyLocation();'>Apply</button>
	<button type="button" onclick='geolocate();'>Use Current Location</button>
	<br>
	<label for="timezone-choice">Timezone:</label>
	<select class="timezone-choice" name="timezone-choice" id="timezone-choice" onchange="applyTimezoneSelection()">
	</select>
	<div class="sopdet-visible-warning" id="sopdet-visible-warning">
	WARNING: Sopdet never rises at this latitude!
	</div>
</div>
<hr>
<div>
	<div class="calendar-display">
		<ul class="months">
			<li class="month">
				<div class="month-name">Tekhy</div>
				<hr>
				<div class="month-season-name">I Akhet</div>
				<ul class="days">
					<li class="day">1</li></ul></li></ul> <!-- single line
							to work around a bug in browser rendering or HTML
							or something else that made a whitespace break things
							-->
		<ul class="intercalary">
		</ul>
	</div>
	<div class="sidebar">
	TODO: Sidebar information when selecting a date
	</div>
</div>
<script>

// the idea is to dynamically generate the html based on the query string
// when we press the button we refresh the page with a new query string.

// this is not necessarily the best way to do this, but allows copy-pasting
// the address-bar without introducing multiple points of failure

///////////////////////////////////////////////////////////////////////////////
// astronomical mathematics stuff
///////////////////////////////////////////////////////////////////////////////

function clamp(x, min, max)
{
	return Math.min(Math.max(x, min), max);
}

function accuracy(a, b)
{
	return Math.abs(a - b) / Math.abs(b);
}

function accuracyScale(a, b, scale)
{
	return Math.abs(a - b) / Math.abs(scale);
}

function accuracyDegrees(a, b)
{
	return accuracyScale(a, b, 360);
}

function isWithinTolerance(a, b, proportion)
{
	return accuracy(a, b) < proportion;
}

function isWithinToleranceScale(a, b, scale, proportion)
{
	return accuracyScale(a, b, scale) < proportion;
}

function isWithinToleranceDegrees(a, b, proportion)
{
	return accuracyDegrees(a, b) < proportion;
}

// helper function to convert degrees to radians
function degreesToRadians(degrees)
{
	return (Math.PI / 180) * degrees;
}

// helper function to convert radians to degrees
function radiansToDegrees(radians)
{
	return (180 / Math.PI) * radians;
}

function RA(hours, minutes, seconds)
{
	// calculate the total right ascension in hours
	const totalRA = hours + (minutes / 60) + (seconds / 3600);

	// convert right ascension from hours to degrees
	return totalRA * 15;
}

function Dec(degrees, minutes, seconds)
{
	if(degrees >= 0)
	{
		return degrees + (minutes / 60) + (seconds / 3600);
	}

	return -(-degrees + (minutes / 60) + (seconds / 3600));
}

function minutesFromDecimal(decimal)
{
	let minutes = (decimal * 60) % 60;
	if(minutes < 0)
	{
		minutes += 60;
	}
	return Math.floor(minutes);
}

function secondsFromDecimal(decimal)
{
	let seconds = (decimal * 3600) % 60;
	if(seconds < 0)
	{
		seconds += 60;
	}
	return seconds;
}

function displayTimeOfDaySeconds(seconds)
{
	return (Math.floor(seconds / 3600)) + "h" + (Math.floor(seconds / 60) % 60) + "m" + (Math.floor(seconds) % 60) + "s";
}
function displayAltAz(v)
{
	return [
		radiansToDegrees(v[0]),
		radiansToDegrees(v[1]) ];
}

function toJulianCenturiesSinceJ2000(julianDay)
{
	return (julianDay - 2451545.0) / 36525;
}

// evaluate a polynomial from a list of coefficients
function evaluateSeriesPolynomial(terms, t)
{
	let evaluation = terms[terms.length - 1];
	for (let i = (terms.length - 2); i >= 0; --i)
	{
		evaluation *= t;
		evaluation += terms[i];
	}
	return evaluation;
}

function gregorianToJulianDay(year, month, day)
{
	// adjust month and year for calculation purposes
	// we need february to be 'last' when calculating the days from months
	if (month <= 2)
	{
		month += 12;
		year -= 1;
	}

	// perform the Julian day calculation
	const centurySkippedLeapDays = Math.floor(year / 100);
	const fourCenturyLeapDays = Math.floor(centurySkippedLeapDays / 4);
	const leapDaysAdjustment = 2 - centurySkippedLeapDays + fourCenturyLeapDays;
	const daysFromYears = Math.floor(365.25 * (year + 4716));

	const daysFromMonths = Math.floor(30.6001 * (month + 1));
	// 30.6 creates the correct pattern of 30/31 day months
	// the extra 0.0001 looks like fine tuning to ensure correct rounding
	// together with the initial month and year adjustments this lets us work
	// out the days to add from the month number allowing us to handle the
	// special case of February by ignoring it.

	// evaluating f for the input values of month and looking at differences
	// shows a pattern alternating between 30 and 31, with 31 repeated.

	/*
		Month: 3, Result: 122, Difference: ???	// (no previous month)
		Month: 4, Result: 153, Difference: 31	// march
		Month: 5, Result: 183, Difference: 30	// april
		Month: 6, Result: 214, Difference: 31	// may
		Month: 7, Result: 244, Difference: 30	// june
		Month: 8, Result: 275, Difference: 31	// july
		Month: 9, Result: 306, Difference: 31	// august
		Month: 10, Result: 336, Difference: 30	// september
		Month: 11, Result: 367, Difference: 31	// october
		Month: 12, Result: 397, Difference: 30	// november
		Month: 13, Result: 428, Difference: 31	// december
		Month: 14, Result: 459, Difference: 31	// january
	*/

	return leapDaysAdjustment + day + daysFromYears + daysFromMonths - 1524.5;
}

function getGMSTSeconds(julianDay)
{
	// convert Julian Day to centuries since J2000.0
	const t = toJulianCenturiesSinceJ2000(julianDay);

	// terms for GMST expression
	const terms =
	[
		24110.54841,
		8640184.812866,
		0.093104,
		-6.2e-6
	];

	// evaluate GSMT0 using the terms
	// based on this expression for GMST in seconds
	// http://www.astro.sunysb.edu/metchev/AST443/times.html
	const jMidnight = julianDay - ((julianDay - 0.5) % 1.0);
	const tMidnight = toJulianCenturiesSinceJ2000(jMidnight);
	const gmst0 = evaluateSeriesPolynomial(terms, tMidnight);

	// this was found on stack exchange...
	const wTerms =
	[
		1.00273790935,
		5.9e-11
	];

	const wStar = evaluateSeriesPolynomial(wTerms, t);

	// get the time of day in seconds from midnight
	const utcSeconds = (julianDay - jMidnight) * 24 * 3600;

	// calculate mod number of seconds in the day...
	return (gmst0 + wStar * utcSeconds) % 86400;
}

// 10th order calculation of obliquity of the ecliptic
// claims to be valid over 10,000 years
function calculateMeanObliquityOfEcliptic(julianDay)
{
	// this is based on J. Meeus, Astronomical Algorithms, p. 135

	// convert Julian Day to centuries since J2000.0
	const t = toJulianCenturiesSinceJ2000(julianDay);

	// terms for the obliquity evaluation
	//const terms =
	//[
	//	84381.448, // J2000 obliquity
	//	-46.8150,
	//	-0.00059,
	//	0.001813
	//];
	const terms100 =
	[
		84381.448, // J2000 obliquity
		-4680.93,
		-1.55,
		1999.25,
		-51.38,
		-249.67,
		-39.05,
		7.12,
		27.87,
		5.79,
		2.45
	];

	//const arcseconds = evaluateSeriesPolynomial(terms, t);
	// so clamping is continuous, but a more accurate approach is to use
	// the long-term mean obliquity and ignore the small differences...
	const arcseconds = evaluateSeriesPolynomial(terms100, clamp(t/100, -1, 1));
	const degrees = arcseconds / 3600.0;
	return degreesToRadians(degrees);
}

function solarMeanAnomaly(julianDay)
{
	const t = toJulianCenturiesSinceJ2000(julianDay);
	// mean anomaly of the Sun
	// (the polynomial is evaluated using Horner's scheme)
	// Meeus p. 308
	return 357.5291092 + t * (35999.0502909 + t * (-0.0001536 + t / 24490000.0));
	// from Meeus also but lower precision...?
	//return 357.52910 + t * (35999.0530 + t * (-0.0001559 + t * -0.00000048));
}

function lunarMeanAnomaly(julianDay)
{
	const t = toJulianCenturiesSinceJ2000(julianDay);
	// mean anomaly of the Moon
	// (the polynomial is evaluated using Horner's scheme)
	// Meeus p. 308
	return 134.9634114 + t * (477198.8676313 + t * (0.0089970 + t *(1.0 / 69699.0 - t / 1471200)));
}

function lunarMeanLongitude(julianDay)
{
	const t = toJulianCenturiesSinceJ2000(julianDay);
	// mean longitude of the Moon
	// (the polynomial is evaluated using Horner's scheme)
	// Meeus p. 308
	return 218.3164591 + t * (481267.88134236 + t * (-0.0013268 + t * (1.0 / 538841.0 - t / 6519400.0)));
}

function lunarMeanElongation(julianDay)
{
	const t = toJulianCenturiesSinceJ2000(julianDay);
	// mean elongation of the Moon
	// (the polynomial is evaluated using Horner's scheme)
	// Meeus p. 308
	return 297.8502042 + t * (445267.1115168 + t * (-0.00163 + t * (1.0 / 545868.0 - t / 113065000)));
}

function lunarArgumentOfLatitude(julianDay)
{
	const t = toJulianCenturiesSinceJ2000(julianDay);
	// mean elongation of the Moon
	// (the polynomial is evaluated using Horner's scheme)
	// Meeus p. 308
	return 93.2720993 + t * (483202.0175273 + t * (-0.0034029 + t * (-1.0 / 3526000.0 + t / 863310000.0)));
}

// Meeus suggests against doing this, but it seems fine to me...
// after all the series is a polynomial interpolation and smooth on a huge timescale.
function approximateMoonPhase(julianDay)
{
	// from Meeus p.319
	// JDE = 2451 550.09765 + 29.530 588 853 k
	//	+ 0.000 1337 T2
	//	- 0.000 000 150 T3
	//	+ 0.000 000 000 73 T4
	const t = toJulianCenturiesSinceJ2000(julianDay);
	const lhs = julianDay - 2451550.09765 + (- 0.0001337 + (0.00000015 - 0.00000000073 * t) * t) * t * t;
	return lhs / 29.530588853;
}

function nextLunarNewMoonDate(julianDay)
{
	// from Meeus p.319
	// JDE = 2451 550.09765 + 29.530 588 853 k
	//	+ 0.000 1337 T2
	//	- 0.000 000 150 T3
	//	+ 0.000 000 000 73 T4
	const t = toJulianCenturiesSinceJ2000(julianDay);
	const k = approximateMoonPhase(julianDay);
	return 2451550.09765
		+ 29.530588853 * k
		+ t * t * (0.0001337 + t * (-0.00000015 + t * 0.00000000073));
}

// TODO: this needs checking. the comments do not match the maths
// on that elongation....
function calculateNutationLongitude(julianDay)
{
	// convert Julian Day to centuries since J2000.0
	const t = toJulianCenturiesSinceJ2000(julianDay);

	// mean elongation of the Moon from the Sun
	// (the polynomial is evaluated using Horner's scheme)
	const l = 218.3164591 + t * (481267.88134236 - t * (0.0013268 + t * (1.0 / 538841.0 -  t / 65194000.0)));

	// mean anomaly of the Sun
	const m = solarMeanAnomaly(julianDay);

	// mean anomaly of the Moon
	const ms = lunarMeanAnomaly(julianDay);

	// moon's argument of latitude
	const f = lunarArgumentOfLatitude(julianDay);

	// longitude of the ascending node of the Moon's mean orbit on the ecliptic
	const omega = 125.044555 - t * (1934.1361849 + t * (0.0020762 + t * (1.0 / 467410.0 - t / 18720000.0)));

	// calculate the nutation in longitude
	const deltaPsi = (-17.20 * Math.sin(omega) - 1.32 * Math.sin(2 * l) - 0.23 * Math.sin(2 * m) + 0.21 * Math.sin(2 * omega)) / 3600.0;

	// Convert the nutation to radians
	return degreesToRadians(deltaPsi);
}

function RADecToCurrentEpoch(julianDay, raJ2000, decJ2000)
{
	// TODO: https://ui.adsabs.harvard.edu/abs/2011A%26A...534A..22V/abstract
	// this is from Meeus p 126
	// convert Julian Day to centuries since J2000.0
	const t = toJulianCenturiesSinceJ2000(julianDay);

	// note these are only valid for J2000.0, the coefficients vary for different epochs
	const zeta = degreesToRadians(
		t * (2306.2181 + t * (0.30188 + t * 0.017998)) / 3600);
	const z = degreesToRadians(
		t * (2306.2181 + t * (1.09468 + t * 0.018203)) / 3600);
	const theta = degreesToRadians(
		t * (2004.3109 + t * (0.42665 + t * 0.041833)) / 3600);

	const cosDecJ2000 = Math.cos(decJ2000);
	const sinDecJ2000 = Math.sin(decJ2000);
	const cosAdjustedRA = Math.cos(raJ2000 + zeta);
	const sinAdjustedRA = Math.sin(raJ2000 + zeta);
	const cosTheta = Math.cos(theta);
	const sinTheta = Math.sin(theta);
	const A = cosDecJ2000 * sinAdjustedRA;
	const B = cosTheta * cosDecJ2000 * cosAdjustedRA - sinTheta * sinDecJ2000;
	const C = sinTheta * cosDecJ2000 * cosAdjustedRA + cosTheta * sinDecJ2000;

	const ra = Math.atan2(A, B) + z;
	const dec = Math.asin(C);
	return [ra, dec];
}

// this produces altitude an azimuth with corrections around J2000.0
function calculateAltitudeAzimuth(
	julianDay, raJ2000, decJ2000, latitude, longitude)
{
	const obliquity = calculateMeanObliquityOfEcliptic(julianDay);
	const nutation = calculateNutationLongitude(julianDay);

	// convert latitude and longitude to radians
	const latRad = degreesToRadians(latitude);
	const lonRad = degreesToRadians(longitude);

	// convert right ascension (RA) and declination (Dec) to radians
	const raJ2000Rad = degreesToRadians(raJ2000);
	const decJ2000Rad = degreesToRadians(decJ2000);

	// then precession to the current epoch...
	const raDec = RADecToCurrentEpoch(julianDay, raJ2000Rad, decJ2000Rad);
	const raRad = raDec[0];
	const decRad = raDec[1];

	// calculate the Greenwich mean sidereal time (GMST)
	// put it into hours...
	let gmst = (getGMSTSeconds(julianDay) / 3600) % 24 ;
	if(gmst < 0)
	{
		gmst += 24;
	}

	// then degrees... then radians
	gmst = degreesToRadians(15 * gmst);

	// apply nutation and obliquity correction to right ascension and declination
	const raRadCorrected = raRad + nutation;
	const decRadCorrected = decRad + obliquity
		- degreesToRadians(84381.448/3600); // change since J2000.0

	// calculate the hour angle
	const hourAngleRad = gmst - lonRad - raRadCorrected;

	// calculate the sine and cosine of the latitude and declination
	const sinLat = Math.sin(latRad);
	const cosLat = Math.cos(latRad);
	const sinDec = Math.sin(decRadCorrected);
	const cosDec = Math.cos(decRadCorrected);
	const tanDec = sinDec / cosDec;
	// ... and the hour angle
	const sinH = Math.sin(hourAngleRad);
	const cosH = Math.cos(hourAngleRad);

	// calculate the altitude and azimuth
	const altitude = Math.asin(
		sinLat * sinDec + cosLat * cosDec * cosH);
	let azimuth = Math.atan2(
		sinH,
		cosH * sinLat - tanDec * cosLat);
	if(azimuth < 0)
	{
		azimuth += 2 * Math.PI;
	}
	// SE - NOTE: we leave it in radians
	// the parameters being in degrees are just a convenience
	return [ altitude, azimuth ];
}

// calculate sopdet location for a given time and place
function evaluateSopdetLocalPosition(julianDay, latitude, longitude)
{
	// TODO: take distance and proper motion into accounts and model
	// the 3d motion of the star to generate RA and Dec for the
	// correct epoch
	const sopdetCelestialCoordinatesJ2000 =
	[
		RA(6, 45, 8.91728),
		Dec(-16, 42, 58.0171)
	];

	return calculateAltitudeAzimuth(
		julianDay,
		sopdetCelestialCoordinatesJ2000[0],
		sopdetCelestialCoordinatesJ2000[1],
		latitude, longitude);
}

function calculateSunRaDec(julianDay)
{
	// this follows the process on Meeus p.152
	// convert Julian Day to centuries since J2000.0
	const t = toJulianCenturiesSinceJ2000(julianDay);

	// mean longitude of the Sun
	const L = 280.46646 + t * (36000.76983 + t * 0.0003032);

	// mean anomaly of the Sun
	const M = solarMeanAnomaly(julianDay);

	// eccentricity of the Earth's orbit
	//const e = 0.016708634 + t * (-0.000042037 - t * 0.0000001267);

	//const Lrad = degreesToRadians(L);
	const Mrad = degreesToRadians(M);

	// equation of center
	const C = ((1.914602 + t * (-0.004817 + t * -0.000014)) * Math.sin(Mrad)) +
			((0.019993 - 0.000101 * t) * Math.sin(2 * Mrad)) +
			(0.000289 * Math.sin(3 * Mrad));

	// true longitude of the Sun
	const trueLongitude = L + C;

	// apparent longitude of the Sun, correcting for nutation and abberation
	const omega = 125.04 - 1934.136 * t;
	const omegaRad = degreesToRadians(omega);
	const lambda = trueLongitude - 0.00569 - 0.00478 * Math.sin(omegaRad);

	// (mean) obliquity of the ecliptic, with correction...
	const epsilonRad = calculateMeanObliquityOfEcliptic(julianDay)
		+ degreesToRadians(0.00256) * Math.cos(omegaRad);

	// calculate the Sun's right ascension (RA)
	const lambdaRad = degreesToRadians(lambda);
	let RA = Math.atan2(
		Math.cos(epsilonRad) * Math.sin(lambdaRad),
		Math.cos(lambdaRad));
	if(RA < 0)
	{
		RA += Math.PI * 2;
	}
	// calculate the Sun's declination (Dec)
	const dec = Math.asin(Math.sin(epsilonRad) * Math.sin(lambdaRad));

	return [ RA, dec ];
}

// calculate position of Sun in the for a given time and place
function evaluateSunCoordinates(julianDay, latitude, longitude)
{
	const sunRADec = calculateSunRaDec(julianDay);
	return calculateAltitudeAzimuth(
		julianDay,
		radiansToDegrees(sunRADec[0]),
		radiansToDegrees(sunRADec[1]),
		latitude,
		longitude);
}

function calculateMoonRADec(julianDay)
{
	const meanLongitudeOfMoon = degreesToRadians(lunarMeanLongitude(julianDay));
	const meanElongationOfMoon = degreesToRadians(lunarMeanElongation(julianDay));
	const meanAnomalyOfSun = degreesToRadians(solarMeanAnomaly(julianDay));
	const meanAnomalyOfMoon = degreesToRadians(lunarMeanAnomaly(julianDay));
	const argumentOfLatitude = degreesToRadians(lunarArgumentOfLatitude(julianDay));
	const t = toJulianCenturiesSinceJ2000(julianDay);
	const A1 = degreesToRadians(119.75 + 131.849 * t);
	const A2 = degreesToRadians(53.09 + 479264.290 * t);
	const A3 = degreesToRadians(313.45 + 481266.484 * t);
	const eccentricity = 1 + t * (-0.002516 - t * 0.0000074); // eccentricity of earth's orbit?
	
	// table of data for longitude and radius
	const LRData =
	[
		// p.309
		[0, 0, 1, 0, 6288774, -20905355],
		[2, 0, -1, 0, 1274027, -3699111],
		[2, 0, 0, 0, 658314, -2955968],
		[0, 0, 2, 0, 213618, -569925],
		[0, 1, 0, 0, -185116, 48888],
		[0, 0, 0, 2, -114332, -3149],
		[2, 0, -2, 0, 58793, 246158],
		[2, -1, -1, 0, 57066, -152138],
		[2, 0, 1, 0, 53322, -170733],
		[2, -1, 0, 0, 45758, -204586],
		[0, 1, -1, 0, -40923, -129620],
		[1, 0, 0, 0, -34720, 108743],
		[0, 1, 1, 0, -30383, 104755],
		[2, 0, 0, -2, 15327, 10321],
		[0, 0, 1, 2, -12528, 0],
		[0, 0, 1, -2, 10980, 79661],
		[4, 0, -1, 0, 10675, -34782],
		[0, 0, 3, 0, 10034, -23210],
		[4, 0, -2, 0, 8548, -21636],
		[2, 1, -1, 0, -7888, 24208],
		[2, 1, 0, 0, -6766, 30824],
		[1, 0, -1, 0, -5163, -8379],
		[1, 1, 0, 0, 4987, -16675],
		[2, -1, 1, 0, 4036, -12831],
		[2, 0, 2, 0, 3994, -10445],
		[4, 0, 0, 0, 3861, -11650],
		[2, 0, -3, 0, 3665, 14403],
		[0, 1, -2, 0, -2689, -7003],
		[2, 0, -1, 2, -2602, 0],
		[2, -1, -2, 0, 2390, 10056],
		[1, 0, 1, 0, -2348, 6322],
		[2, -2, 0, 0, 2236, -9884],
		// p.310
		[0, 1, 2, 0, -2120, 5751],
		[0, 2, 0, 0, -2069, 0],
		[2, -2, -1, 0, 2048, -4950],
		[2, 0, 1, -2, -1773, 4130],
		[2, 0, 0, 2, -1595, 0],
		[4, -1, -1, 0, 1215, -3958],
		[0, 0, 2, 2, -1110, 0],
		[3, 0, -1, 0, -892, 3258],
		[2, 1, 1, 0, -810, 2616],
		[4, -1, -2, 0, 759, -1897],
		[0, 2, -1, 0, -713, -2117],
		[2, 2, -1, 0, -700, 2354],
		[2, 1, -2, 0, 691, 0],
		[2, -1, 0, -2, 596, 0],
		[4, 0, 1, 0, 549, -1423],
		[0, 0, 4, 0, 537, -1117],
		[4, -1, 0, 0, 520, -1571],
		[1, 0, -2, 0, -487, -1739],
		[2, 1, 0, -2, -399, 0],
		[0, 0, 2, -2, -381, -4421],
		[1, 1, 1, 0, 351, 0],
		[3, 0, -2, 0, -340, 0],
		[4, 0, -3, 0, 330, 0],
		[2, -1, 2, 0, 327, 0],
		[0, 2, 1, 0, -323, 1165],
		[1, 1, -1, 0, 299, 0],
		[2, 0, 3, 0, 294, 0],
		[2, 0, -1, -2, 0, 8752]
	];
	
	const BData =
	[
		// p.311, note the data is in pairs, in an unhelpful layout
		// TODO: make the data a single list.
		[0, 0, 0, 1, 5128122, 0, 0, 1, -3, 111], 
		[0, 0, 1, 1, 280602, 4, 0, -2, 1, 671], 
		[0, 0, 1, -1, 277693, 2, 0, 0, -3, 607], 
		[2, 0, 0, -1, 173237, 2, 0, 2, -1, 596], 
		[2, 0, -1, 1, 55413, 2, -1, 1, -1, 491], 
		[2, 0, -1, -1, 46271, 2, 0, -2, 1, -451], 
		[2, 0, 0, 1, 32573, 0, 0, 3, -1, 439], 
		[0, 0, 2, 1, 17198, 2, 0, 2, 1, 422], 
		[2, 0, 1, -1, 9266, 2, 0, -3, -1, 421], 
		[0, 0, 2, -1, 8822, 2, 1, -1, 1, -366], 
		[2, -1, 0, -1, 8216, 2, 1, 0, 1, -351], 
		[2, 0, -2, -1, 4324, 4, 0, 0, 1, 331], 
		[2, 0, 1, 1, 4200, 2, -1, 1, 1, 315], 
		[2, 1, 0, -1, -3359, 2, -2, 0, -1, 302], 
		[2, -1, -1, 1, 2463, 0, 0, 1, 3, -283], 
		[2, -1, 0, 1, 2211, 2, 1, 1, -1, -229], 
		[2, -1, -1, -1, 2065, 1, 1, 0, -1, 223], 
		[0, 1, -1, -1, -1870, 1, 1, 0, 1, 223], 
		[4, 0, -1, -1, 1828, 0, 1, -2, -1, -220], 
		[0, 1, 0, 1, -1794, 2, 1, -1, -1, -220], 
		[0, 0, 0, 3, -1749, 1, 0, 1, 1, -185], 
		[0, 1, -1, 1, -1565, 2, -1, -2, -1, 181], 
		[1, 0, 0, 1, -1491, 0, 1, 2, 1, -177], 
		[0, 1, 1, 1, -1475, 4, 0, -2, -1, 176], 
		[0, 1, 1, -1, -1410, 4, -1, -1, -1, 166], 
		[0, 1, 0, -1, -1344, 1, 0, 1, -1, -164], 
		[1, 0, 0, -1, -1335, 4, 0, 1, -1, 132], 
		[0, 0, 3, 1, 1107, 4, 0, -1, -1, -119], 
		[4, 0, 0, -1, 1021, 4, -1, 0, -1, 115], 
		[4, 0, -1, 1, 8332, 2, -2, 0, 1, 107]
	];
	
	let longitudeSum = 3958 * Math.sin(A3)
		+ 1962 * Math.sin(meanLongitudeOfMoon - argumentOfLatitude)
		+ 318 * Math.sin(A2);
	let radiusSum = 0;
	let latitudeSum = -2235 * Math.sin(meanLongitudeOfMoon)
		+ 382 * Math.sin(A3)
		+ 175 * Math.sin(A1 - argumentOfLatitude)
		+ 175 * Math.sin(A1 + argumentOfLatitude)
		+ 127 * Math.sin(meanLongitudeOfMoon - meanAnomalyOfMoon)
		- 115 * Math.sin(meanLongitudeOfMoon + meanAnomalyOfMoon);
	for(const coefficients of LRData)
	{
		let argument =
			coefficients[0] * meanElongationOfMoon
			+ coefficients[1] * meanAnomalyOfSun
			+ coefficients[2] * meanAnomalyOfMoon
			+ coefficients[3] * argumentOfLatitude;
		if(Math.abs(coefficients[1]) == 1)
		{
			argument *= eccentricity;
		}
		else if(Math.abs(coefficients[1]) == 2)
		{
			argument *= eccentricity * eccentricity;
		}
		
		longitudeSum += coefficients[4] * Math.sin(argument);
		radiusSum += coefficients[5] * Math.cos(argument);
	}
	
	for(const coefficients of BData)
	{
		for(let i = 0; i < 2; ++i)
		{
			const offset = i *5;
			let argument =
				coefficients[0 + offset] * meanElongationOfMoon
				+ coefficients[1 + offset] * meanAnomalyOfSun
				+ coefficients[2 + offset] * meanAnomalyOfMoon
				+ coefficients[3 + offset] * argumentOfLatitude;
			if(Math.abs(coefficients[1 + offset]) == 1)
			{
				argument *= eccentricity;
			}
			else if(Math.abs(coefficients[1 + offset]) == 2)
			{
				argument *= eccentricity * eccentricity;
			}
			
			latitudeSum += coefficients[4 + offset] * Math.sin(argument);
		}
	}
	
	radiusSum /= 1000; // its in metres.
	radiusSum += 385000.56;
	
	latitudeSum /= 1000000; // in milionths of degrees
	latitudeSum = degreesToRadians(latitudeSum);
	
	longitudeSum /= 1000000; // in milionths of degrees
	longitudeSum = degreesToRadians(longitudeSum);
	
	longitudeSum += meanLongitudeOfMoon;
	
	// to ra and dec...
	// (mean) obliquity of the ecliptic
	const epsilonRad = calculateMeanObliquityOfEcliptic(julianDay);

	// calculate the right ascension (RA)
	let RA = Math.atan2(
		Math.cos(epsilonRad) * Math.sin(longitudeSum)
			- Math.tan(latitudeSum) * Math.sin(epsilonRad),
		Math.cos(longitudeSum));
	if(RA < 0)
	{
		RA += Math.PI * 2;
	}
	// calculate the declination (Dec)
	const dec = Math.asin(Math.sin(latitudeSum) * Math.cos(epsilonRad)
		+ Math.cos(latitudeSum) * Math.sin(epsilonRad) * Math.sin(longitudeSum));
		
	return [ RA, dec ];
}

// calculate position of Sun in the for a given time and place
function evaluateMoonCoordinates(julianDay, latitude, longitude)
{
	// note i don't think this is in j2000 (!)
	const sunRADec = calculateMoonRADec(julianDay);
	return calculateAltitudeAzimuth(
		julianDay,
		radiansToDegrees(sunRADec[0]),
		radiansToDegrees(sunRADec[1]),
		latitude,
		longitude);
}

const sopdetMaxVisibleLatitude = 90 + Dec(-16, 42, 58.0171);
const arcusVisionisSopdet = degreesToRadians(10);

// these have timezones tacked on.
const locations =
[
	[51.4769, -0.0005, 0, 1],		// Greenwich Observatory
	[29.9792, -31.1342, 2, 3],		// Great Pyramid of Giza
	[40.6892, 74.0445, -5, -4],		// Statue of Liberty
	[27.1751, -78.0421, 5.5, 5.5],	// Taj Mahal
	[-33.8568, -151.2153, 10, 9],	// Sydney Opera House
	[-22.9519, 43.2105, -3, -3],	// Christ the Redeemer
];

const timezones =
[
	["UTC-12", -12],
	["UTC-11", -11],
	["UTC-10", -10],
	["UTC-9", -9],
	["UTC-8", -8],
	["UTC-7", -7],
	["UTC-6", -6],
	["UTC-5", -5],
	["UTC-4", -4],
	["UTC-3", -3],
	["UTC-2", -2],
	["UTC-1", -1],
	["UTC", 0],
	["UTC+1", 1],
	["UTC+2", 2],
	["UTC+3", 3],
	["UTC+4", 4],
	["UTC+5", 5],
	["UTC+5.5", 5.5],
	["UTC+6", 6],
	["UTC+7", 7],
	["UTC+8", 8],
	["UTC+9", 9],
	["UTC+10", 10],
	["UTC+11", 11],
];

// approximate apparent angular radius and atmospheric distortion (from wikipedia).
const sunRiseAngle = degreesToRadians(-0.83);

function calculateNextSunrise(julianDay, latitude, longitude)
{
	// try to find a point where the sun is below the horizon to start...
	// work out its position at each hour for the next 24 hours to start.
	// it is simple minded but allows a binary search to complete the problem.
	// ... in most cases

	let hoursSunAltAz = new Array(24);
	hoursSunAltAz[0] = evaluateSunCoordinates(julianDay, latitude, longitude);
	let lastSunAlt = hoursSunAltAz[0][0];
	let riseHour = -1;
	let timeStep = 1.0 / 24.0;
	for(let i = 1; i < 96; ++i)
	{
		hoursSunAltAz[i] = evaluateSunCoordinates(
			julianDay + i*timeStep, latitude, longitude);
		if((riseHour < 0) && (hoursSunAltAz[i][0] > sunRiseAngle) && (lastSunAlt < sunRiseAngle))
		{
			riseHour = i;
			break;
		}
		lastSunAlt = hoursSunAltAz[i][0];
	}

	// binary search it a few steps...
	let lower = riseHour - 1;
	let upper = riseHour;
	let lowerCoords = evaluateSunCoordinates(
			julianDay + lower * timeStep, latitude, longitude);
	let upperCoords = evaluateSunCoordinates(
			julianDay + upper * timeStep, latitude, longitude);
	for(let i = 1; i < 16; ++i)
	{
		let newValue = (lower + upper) / 2.0;
		let newCoords = evaluateSunCoordinates(
			julianDay + newValue * timeStep, latitude, longitude);
		if(newCoords[0] < sunRiseAngle)
		{
			lower = newValue;
			lowerCoords = newCoords;
		}
		else
		{
			upper = newValue;
			upperCoords = newCoords;
		}

	}

	return (lower + upper) / 2.0;
}

function calculateNextSunset(julianDay, latitude, longitude)
{
	// try to find a point where the sun is below the horizon to start...
	// work out its position at each hour for the next 24 hours to start.
	// it is simple minded but allows a binary search to complete the problem.
	// ... in most cases

	let hoursSunAltAz = new Array(24);
	hoursSunAltAz[0] = evaluateSunCoordinates(julianDay, latitude, longitude);
	let lastSunAlt = hoursSunAltAz[0][0];
	let riseHour = -1;
	let timeStep = 1.0 / 24.0;
	for(let i = 1; i < 96; ++i)
	{
		hoursSunAltAz[i] = evaluateSunCoordinates(
			julianDay + i*timeStep, latitude, longitude);
		if((riseHour < 0) && (hoursSunAltAz[i][0] < sunRiseAngle) && (lastSunAlt > sunRiseAngle))
		{
			riseHour = i;
			break;
		}
		lastSunAlt = hoursSunAltAz[i][0];
	}

	// binary search it a few steps...
	let lower = riseHour - 1;
	let upper = riseHour;
	let lowerCoords = evaluateSunCoordinates(
			julianDay + lower * timeStep, latitude, longitude);
	let upperCoords = evaluateSunCoordinates(
			julianDay + upper * timeStep, latitude, longitude);
	for(let i = 1; i < 16; ++i)
	{
		let newValue = (lower + upper) / 2.0;
		let newCoords = evaluateSunCoordinates(
			julianDay + newValue * timeStep, latitude, longitude);
		if(newCoords[0] > sunRiseAngle)
		{
			lower = newValue;
			lowerCoords = newCoords;
		}
		else
		{
			upper = newValue;
			upperCoords = newCoords;
		}

	}

	return (lower + upper) / 2.0;
}

///////////////////////////////////////////////////////////////////////////////
// tests for astronomical algorithms
///////////////////////////////////////////////////////////////////////////////

const passedHtml = '<span style="color:blue">PASSED</span>';
const failedHtml = '<span style="color:red">FAILED</span>';

function testJulianDay01Jan2019()
{
	const testValue = gregorianToJulianDay(2019,1,1);
	return [ "Julian day number for 2019-1-1 = 2458484.5",
		(testValue == 2458484.5)
			? passedHtml : (failedHtml + ", expected 2458484.5, got " + testValue)];
}

function testGMST01Jan20190800()
{
	// checked here:
	// https://phpsciencelabs.com/sidereal-time-calculator/index.php
	// note it only goes to 3dp...
	const testValue = getGMSTSeconds(2458484.5 + (8 / 24));
	return [ "GMST at 2019-1-1 08:00:00",
		isWithinTolerance(testValue, 52965.379, 0.001)
			? (passedHtml + ", test error = " + accuracy(testValue, 52965.379)*100 + "%")
			: (failedHtml + ", expected 52965.37916293584, got " + testValue)];
}

//
function testGMST26Aug1955170314()
{
	// checked here:
	// https://astrogreg.com/snippets/greenwichMeanSiderealTime.html
	const date = gregorianToJulianDay(1955, 8, 26) + 17/24 + 3/(24*60)+ 14/(24*3600);
	let testValue = (getGMSTSeconds(date) / 3600) % 24;
	if(testValue < 0)
	{
		testValue += 24;
	}
	const checkValue = RA(15, 19, 53.98) / 15;
	return [ "GMST at 1955-08-26 17:03:14",
		isWithinTolerance(testValue, checkValue, 0.001)
			? (passedHtml + ", test error = " + accuracy(testValue, checkValue)*100 + "%")
			: (failedHtml + ", expected " + checkValue + ", got " + testValue)];
}

function testMeanObliquity2458850()
{
	const testValue = radiansToDegrees(calculateMeanObliquityOfEcliptic(2458850));
	const checkValue = 84372.086416 / 3600;
	return [ "Mean Obliquity of the Ecliptic @ JD 2458850",
		isWithinToleranceDegrees(testValue, checkValue, 0.001)
			? (passedHtml + ", test error = " + accuracyDegrees(testValue, checkValue)*100 + "%")
			: (failedHtml + ", expected " + checkValue + ", got " + testValue)];
}

function testMeanObliquity17214255()
{
	const testValue = radiansToDegrees(calculateMeanObliquityOfEcliptic(1721425.5));
	const checkValue = 23.6947529287;
	return [ "Mean Obliquity of the Ecliptic @ JD 1721425.5",
		isWithinToleranceDegrees(testValue, checkValue, 0.001)
			? (passedHtml + ", test error = " + accuracyDegrees(testValue, checkValue)*100 + "%")
			: (failedHtml + ", expected " + checkValue + ", got " + testValue)];
}

function testRADecAltAz1()
{
	//15-05-2021
	// test value from here with longitude negative...
	// https://astrogreg.com/convert_ra_dec_to_alt_az.html
	const testValue = radiansToDegrees(
		calculateAltitudeAzimuth(
			2459349.5, RA(5,0,0), 50, 50, 50)[0]);
	const checkValue = Dec(27, 21, 22);
	return [ "RA/Dec to Alt @ JD 2459349.5",
		isWithinToleranceDegrees(testValue, checkValue, 0.01)
			? (passedHtml + ", test error = " + accuracyDegrees(testValue, checkValue)*100 + "%")
			: (failedHtml + ", expected " + checkValue + ", got " + testValue)];
}

function testRADecAltAz2()
{
	//15-05-2021
	// test value from here with longitude negative...
	// https://astrogreg.com/convert_ra_dec_to_alt_az.html
	const testValue = radiansToDegrees(
		calculateAltitudeAzimuth(
			2459349.5, RA(5,0,0), 50, 50, 50)[1]);
	const checkValue = Dec(316-180, 29, 14.60);
	return [ "RA/Dec to Az @ JD 2459349.5",
		isWithinToleranceDegrees(testValue, checkValue, 0.01)
			? (passedHtml + ", test error = " + accuracyDegrees(testValue, checkValue)*100 + "%")
			: (failedHtml + ", expected " + checkValue + ", got " + testValue)];
}

function testRADecAltAz3()
{
	// worked example from Meeus...
	const date = gregorianToJulianDay(1987, 4, 10) + 19/24 + 21/(24*60);
	const testValue = radiansToDegrees(
		calculateAltitudeAzimuth(
			date,
			RA(23,9,16.641), Dec(-6,43,11.61),
			Dec(38,55,17), Dec(77, 3, 56))[0]);
	const checkValue = Dec(15.1249,0,0); // book value
	return [ "RA/Dec to Alt @ JD " + date,
		isWithinToleranceDegrees(testValue, checkValue, 0.01)
			? (passedHtml + ", test error = " + accuracyDegrees(testValue, checkValue)*100 + "%")
			: (failedHtml + ", expected " + checkValue + ", got " + testValue)];
}

function testRADecAltAz4()
{
	// worked example from https://astrogreg.com/radec_to_altaz_testtdata.html...
	//1955-Aug-26 17:03:14
	const date = gregorianToJulianDay(1955, 8, 26) + 17/24 + 3/(24*60)+ 14/(24*3600);
	// LST = 7.92504, HA = -2.21260
	const testValue = radiansToDegrees(
		calculateAltitudeAzimuth(
			date,
			12.7006088, 152.0646154,
			81.9121742352522, -248.896246076003)[0]);
	const checkValue = 19.4223000000;
	return [ "RA/Dec to Alt @ JD " + date,
		isWithinToleranceDegrees(testValue, checkValue, 0.01)
			? (passedHtml + ", test error = " + accuracyDegrees(testValue, checkValue)*100 + "%")
			: (failedHtml + ", expected " + checkValue + ", got " + testValue)];
}

function testSunRADec1()
{
	// from https://www.hko.gov.hk/en/gts/astronomy/sun_ra_dec.htm
	const testValue = radiansToDegrees(
		calculateSunRaDec(2460120.5)[0]);
	const checkValue = RA(6, 14, 02);
	return [ "Sun RA @ JD 2460120.5",
		isWithinToleranceDegrees(testValue, checkValue, 0.01)
			? (passedHtml + ", test error = " + accuracyDegrees(testValue, checkValue)*100 + "%")
			: (failedHtml + ", expected " + checkValue + ", got " + testValue)];
}

function testSunRADec1a()
{
	// from https://www.hko.gov.hk/en/gts/astronomy/sun_ra_dec.htm
	const testValue = radiansToDegrees(
		calculateSunRaDec(2460120.5)[1]);
	const checkValue = Dec(23, 23, 57);
	return [ "Sun Dec @ JD 2460120.5",
		isWithinToleranceDegrees(testValue, checkValue, 0.01)
			? (passedHtml + ", test error = " + accuracyDegrees(testValue, checkValue)*100 + "%")
			: (failedHtml + ", expected " + checkValue + ", got " + testValue)];
}

function testSunRADec2()
{
	// from Meeus p.153
	const testValue = radiansToDegrees(
		calculateSunRaDec(2448908.5)[0]);
	const checkValue = RA(13, 13, 30.7);
	return [ "Sun RA @ JD 2448908.5",
		isWithinToleranceDegrees(testValue, checkValue, 0.01)
			? (passedHtml + ", test error = " + accuracyDegrees(testValue, checkValue)*100 + "%")
			: (failedHtml + ", expected " + checkValue + ", got " + testValue)];
}

function testSunRADec2a()
{
	// from Meeus p.153
	const testValue = radiansToDegrees(
		calculateSunRaDec(2448908.5)[1]);
	const checkValue = -Dec(7, 47, 1);
	return [ "Sun Dec @ JD 2448908.5",
		isWithinToleranceDegrees(testValue, checkValue, 0.01)
			? (passedHtml + ", test error = " + accuracyDegrees(testValue, checkValue)*100 + "%")
			: (failedHtml + ", expected " + checkValue + ", got " + testValue)];
}

function testSunAlt1()
{
	const sunRADec = calculateSunRaDec(2448908.5);
	const testValue = radiansToDegrees(
		calculateAltitudeAzimuth(
			2448908.5,
			radiansToDegrees(sunRADec[0]),
			radiansToDegrees(sunRADec[1]),
			Dec(51, 30, 0), Dec(0, 35, 0))[0]);
	// value from cartes du ciel
	// -46 13 23.3, 04 04 22
	const checkValue = Dec(-46, 13, 23.3);
	return [ "Sun altitude @ JD 2448908.5",
		isWithinToleranceDegrees(testValue, checkValue, 0.01)
			? (passedHtml + ", test error = " + accuracyDegrees(testValue, checkValue)*100 + "%")
			: (failedHtml + ", expected " + checkValue + ", got " + testValue)];
}

function testSunAlt2()
{
	const sunRADec = calculateSunRaDec(2448908.75);
	const testValue = radiansToDegrees(
		calculateAltitudeAzimuth(
			2448908.75,
			radiansToDegrees(sunRADec[0]),
			radiansToDegrees(sunRADec[1]),
			Dec(51, 30, 0), Dec(0, 35, 0))[0]);
	// value from cartes du ciel
	// -04 22 27.4, 97 08 33
	const checkValue = Dec(-4, 23, 24.4);
	return [ "Sun altitude @ JD 2448908.75",
		isWithinToleranceDegrees(testValue, checkValue, 0.01)
			? (passedHtml + ", test error = " + accuracyDegrees(testValue, checkValue)*100 + "%")
			: (failedHtml + ", expected " + checkValue + ", got " + testValue)];
}

function testSunAlt3()
{
	const sunRADec = calculateSunRaDec(2448909);
	const testValue = radiansToDegrees(
		calculateAltitudeAzimuth(
			2448909,
			radiansToDegrees(sunRADec[0]),
			radiansToDegrees(sunRADec[1]),
			Dec(51, 30, 0), Dec(0, 35, 0))[0]);
	// value from cartes du ciel
	// 30 30 09.7, 97 08 33
	const checkValue = Dec(30, 30, 9.7);
	return [ "Sun altitude @ JD 2448909",
		isWithinToleranceDegrees(testValue, checkValue, 0.01)
			? (passedHtml + ", test error = " + accuracyDegrees(testValue, checkValue)*100 + "%")
			: (failedHtml + ", expected " + checkValue + ", got " + testValue)];
}

function testSopdetAlt1()
{
	const sopdetAltAz = evaluateSopdetLocalPosition(
		2448909, Dec(51, 30, 0), Dec(0, 35, 0));
	const testValue = radiansToDegrees(sopdetAltAz[0]);
	// value from cartes du ciel
	// -19 29 17.0, 267 25 46
	const checkValue = Dec(-19, 29, 17.0);
	return [ "Sopdet altitude @ JD 2448909",
		isWithinToleranceDegrees(testValue, checkValue, 0.01)
			? (passedHtml + ", test error = " + accuracyDegrees(testValue, checkValue)*100 + "%")
			: (failedHtml + ", expected " + checkValue + ", got " + testValue)];
}

function testSopdetAlt2()
{
	const sopdetAltAz = evaluateSopdetLocalPosition(
		2462788, Dec(51, 30, 0), Dec(0, 35, 0));
	const testValue = radiansToDegrees(sopdetAltAz[0]);
	// value from cartes du ciel
	// -19 08 44.1, 266 54 50
	const checkValue = Dec(-19, 08, 44.1);
	return [ "Sopdet altitude @ JD 2462788",
		isWithinToleranceDegrees(testValue, checkValue, 0.01)
			? (passedHtml + ", test error = " + accuracyDegrees(testValue, checkValue)*100 + "%")
			: (failedHtml + ", expected " + checkValue + ", got " + testValue)];
}

function testSopdetAlt2a()
{
	const sopdetAltAz = evaluateSopdetLocalPosition(
		2462788, Dec(51, 30, 0), Dec(0, 35, 0));
	const testValue = radiansToDegrees(sopdetAltAz[1]);
	// value from cartes du ciel
	// -19 08 44.1, 266 54 50
	const checkValue = Dec(266-180, 54, 50);
	return [ "Sopdet azimuth @ JD 2462788",
		isWithinToleranceDegrees(testValue, checkValue, 0.01)
			? (passedHtml + ", test error = " + accuracyDegrees(testValue, checkValue)*100 + "%")
			: (failedHtml + ", expected " + checkValue + ", got " + testValue)];
}

function testSopdetAlt3()
{
	const sopdetAltAz = evaluateSopdetLocalPosition(
		2462573.5, Dec(51, 30, 0), Dec(0, 35, 0));
	const testValue = radiansToDegrees(sopdetAltAz[0]);
	// value from cartes du ciel
	//  -00 23 56.2, 242 57 42
	const checkValue = -Dec(0,23,56.2);
	return [ "Sopdet altitude @ JD 2462573.5",
		isWithinToleranceDegrees(testValue, checkValue, 0.01)
			? (passedHtml + ", test error = " + accuracyDegrees(testValue, checkValue)*100 + "%")
			: (failedHtml + ", expected " + checkValue + ", got " + testValue)];
}

function testSopdetAlt3a()
{
	const sopdetAltAz = evaluateSopdetLocalPosition(
		2462573.5, Dec(51, 30, 0), Dec(0, 35, 0));
	const testValue = radiansToDegrees(sopdetAltAz[1]);
	// value from cartes du ciel
	//  -00 23 56.2, 242 57 42
	const checkValue = Dec(242-180,57,42);
	return [ "Sopdet azimuth @ JD 2462573.5",
		isWithinToleranceDegrees(testValue, checkValue, 0.01)
			? (passedHtml + ", test error = " + accuracyDegrees(testValue, checkValue)*100 + "%")
			: (failedHtml + ", expected " + checkValue + ", got " + testValue)];
}

function testSolarMeanAnomaly0()
{
	let testValue =
		solarMeanAnomaly(2448908.5) % 360;
	if(testValue < 0)
	{
		testValue += 360;
	}
	// value from Meeus p. 151
	const checkValue = 360 + (-2241.00604 % 360);
	// from JPL HORIZONS there is... 1.233694062109721E+02
	return [ "Solar mean anomaly @ JD 2448908.5",
		isWithinToleranceDegrees(testValue, checkValue, 0.01)
			? (passedHtml + ", test error = " + accuracyDegrees(testValue, checkValue)*100 + "%")
			: (failedHtml + ", expected " + checkValue + ", got " + testValue)];
}

function testSolarMeanAnomaly1()
{
	const testValue =
		solarMeanAnomaly(2458849.5) % 360;
	// value from JPL HORIZONS
	const checkValue = 1.067387414341312e+02;
	return [ "Solar mean anomaly @ JD 2458849.5",
		isWithinToleranceDegrees(testValue, checkValue, 0.01)
			? (passedHtml + ", test error = " + accuracyDegrees(testValue, checkValue)*100 + "%")
			: (failedHtml + ", expected " + checkValue + ", got " + testValue)];
}

function testSolarMeanAnomaly2()
{
	const testValue =
		solarMeanAnomaly(2459215.5) % 360;
	// value from JPL HORIZONS
	const checkValue = 7.972021595766104E+01;
	return [ "Solar mean anomaly @ JD 2459215.5",
		isWithinToleranceDegrees(testValue, checkValue, 0.01)
			? (passedHtml + ", test error = " + accuracyDegrees(testValue, checkValue)*100 + "%")
			: (failedHtml + ", expected " + checkValue + ", got " + testValue)];
}

const testFunctions =
[
	testJulianDay01Jan2019,
	testGMST26Aug1955170314,
	testGMST01Jan20190800,
	testMeanObliquity2458850,
	testMeanObliquity17214255,
	testRADecAltAz1,
	testRADecAltAz2,
	testRADecAltAz3,
	//testRADecAltAz4,
	testSunRADec1,
	testSunRADec1a,
	testSunRADec2,
	testSunRADec2a,
	testSunAlt1,
	testSunAlt2,
	testSunAlt3,
	testSopdetAlt1,
	testSopdetAlt2,
	testSopdetAlt2a,
	testSopdetAlt3,
	testSopdetAlt3a,
	testSolarMeanAnomaly0,
	//testSolarMeanAnomaly1,
	//testSolarMeanAnomaly2,
];


///////////////////////////////////////////////////////////////////////////////
// base 64 image data
///////////////////////////////////////////////////////////////////////////////

const imageDataN5 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAYAAACM/rhtAAAD5klEQVRYw82Za0iTURjHd3HL2kqbTVpqecmSCjWtpaNSU8vKTWxBRRfoglhWkBZBQVDoCMKo9qUvERXewi9BECRaLqysKKKr6wZFF9IZhUVhPm/PM89r25zl9u524M/Yu73n/Hbec57nf56JRN618ahVqFOo66guuUzyQRUh6yGNkUs+4jUrqh1lRhnZPX5vOlSDWCz6ocuIAlPlHLDU54Dtrh44q5FzVO89A9xoyLF/h75L9+C99awPn7c0VMsEZRi3b9sMeN1WNAzof3rVWgR073hFGFBfqFRfgMlQ1VKJuL9iQxJ0d+o5T8Fc1d1ZDDvWJwH1SX2zMbxqapQlIVbBdTTlglAwV3U05gL2TbNpYWN51OJo4edlqWl9cb6G40Vrl8agsdiYo565LkO+Bn4+LvUbHC8aoyR/Cg+pHs2as9CvCgScIySbScv/1mR1PK4L2x09BArO4XFzbE1WjwSXSjuLFm+g4Rw3DtvdbkNQC23/YMHxqkAGFiedMwQFUIpRwQYkBhbMnTJOw16M8sGG40UZh5iGEj/lSUpFoQJILCx32w2GkZJ5qMDxIibmgkRmchxCOnt0uRCqtiTD2pVxcKA8BZ5eWSr4BxMTs2qidrJF3nZUV6sF9H9c2ZoEqD+uBXql92ePzhMESUzMT4qs5N286eTTzWJQjAuDxhMLnO5vNmfB2HAp986ywmvI3nt6sJtecr/ednL6SAaszNW4hVhdFAPmQ+mCZtHuzFWRcpu3HRzcnjKwv2ymW4jDu2fR54IAiU0Q4BlT5u+M2ZHcwPNVTtehy8hlpasEr0M7oJBH/PW+ATTq8IHdm6ZD/7NBSHrdszl5YLI6HL49KOEEP2Ihm4T04FIBzIhXcsnxSthQMrU/aaoSYiePhc7mPEGzN7RJhIYZftba63K4C8fmQ+u5RT7xko5hxlxTOTvkMokJmfhAbdTNDcFUN/dvqrObhZchbBbsdqtqa+jYLcrrjnZryLB+vh18w0oM7gwrs/yJQQcsX5fo1vKHxKHpBhaiJIOHprQRj5109Ov1YzVhJPXc0XPTYsb989g5dHDPz46GX08Ce3DP1Y7u4M6XPqylhVMCAklw+iUaPq2pPSkeWQt00YA50a/VBFbysHpSPHIqvyXGKeDWxTyfb5ybTcLKb45rskYqFffvtBcwhcdJ3AywayMWMKXCC5jDSsAUQCnKv2hZ5jHom2vLgdx3hFLm0xKwa8tG1WGe/K5NnQho66Ht/GL44uInyVFTRkALBqaqObAwMwokYjFfRM8ORLVfgTKgatnfEO+jIuV9aFT7JqnkNlmY+C1ee4i6ijqJKvX2b4g/CwJdaIumKikAAAAASUVORK5CYII=";

const imageDataN10 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAYAAACM/rhtAAAFWUlEQVRYw82YC0yTVxSACwZoeRWEAQXMeG1xA2QyN8RgjATYgDo23FDMTIw6deoknY4sGzMoIMg2cEiHgsB8MeaG4CgiL0fIeKhLNIbgaz5GUKMDeTiwQP9zdw75a8AUqUBLb/IlpPyPL+f+95x7j0Aw+eGGrEb2IWeQa0gv0sf/fRpJRz5CHAR6Gs5IAtJqb28PsStWQFZmJtRVVcG11la4194Od+/cgbbLl7kzCgWXnpoK70mlYGlpyeE9TcgWxFoXYhLkoJGRkTIyImKovLRU9V93NygfP2ba0P3wITtcUAALAwIAn9OD7EaspktuI01dWGjo4MXz54e0lRqPyvJyeMPPj0Q7kIipiJkjv9ja2nJFR44MTlVsNP09PSw1ORnMTE1JNA0xflE5W6R5nq8vd72tjZtOudH8WV8PzhIJo0AgJtrKWSAti4OC4N9790BXcmowAODp4QG85ISRNEJOvunvzzrv32e6llNzAyVdnJ1Jcu9EgtucHB3Z7Rs39CanpqmhAczMzEgyctzEi2mkv7ysTO9yaihv8qtbYwoqjl25UuuHtV66xAry8phs2za2TCplC/CzeMXLi3m4uzNfHx94NywMtm7eDAfkcvirpQUGensnfCZd4z9/PvB5cszwxvByf1+58ryboa66enDD+vUqV1dXsLe3YyEhwWzL5g2QkryTk+/PUOUfyhkuQHLkP6j2piZxsritsEwazubMcWV2s2fDipgYKD5+HHq7usZ9T1VFBfAlUzxa8MDaNWs03tDb2anCcjaAK+2Jnd1siF0ZA7kHs+FsbSX7o057jh3Jh/Xr1oCrqwtQmfwyPh46sCxqeidfcbao5cyo/JxrbBxz0ZO+PpafmzsskUiG3Nxehq+/ioeaqvIXktLE2drTDKMLvj7eYGVlxZISE6HvmYgWHjpEgs1qwXdemzt3zAU3r15lS5csYWKxGHZsj4O6moopi2kiJTkRnJ0l4O3tDReam59G89GDB2Bubk4bDCcSTNsukz2Vq6mspClgQUGLoLSkGHQhNpozp8vY8uj3QSQS0Yw9lYwID6coriLBmlMlJSP/KDp6lBMJhfDppk90LvYsybt3UtTYzoSEEZe0lBQS3E+Ct9tv3QJMGUBySbu+0bucmjxcfLa2NmyHTAb8am4Q4G7lCYUWdxZsT8quGZNTU1hwEPDbZ9LISPoG7wooarNmzWLxX8hmXE5N9v4MMMWAoaCSpphFR0cZjJya+B0ymmKVQCQSDtZUKQxKjig7WUyCjyiC7YryEoOLIE0zul0kwbPZWRkGF8HPZZ+R4E8k+P3GDesMTjA0JJjjD2yCKL95vgYlV1utABuxmARfJUFLY2PjgeKiwwYjmJ6WrEKv66O3Wz+vio0xGMFFgQEkmDhacLGFhQU7VXZixldzfl4ORx0Mvs0yZtR/uPyDoZkWfGuBP317P2o6kyzAkjeclytXzpRcAm6K0aMbcRzvZJeBW3JlZUWpSt9yRccKGXbBqP6ufd65mLb/FwIDA5S01PUlp/j9N+bu7kZyRdq0PlyQfzBRDulDEsss8/F5neQaEZG2/Rkvkgxc+LaqQod1+kTxUebl5cn4A5LNZLqp5/Cb5A7kZHHTLUebYxsbMcmV8A2rSQ36JtNpdS+PjuJOlU49T2LFguClS2i19iNxfMNqymM+UmdhYT5ycJ9MWcSOAyeNDOdMTEwoz/2KeOiiVx1EfTxjYyMlbTA2bVzH5NmZDNOSpg0n9923e7jVH8dynp4eHN/OyEN8BXoY1DeJ4TN+E5amDmtr6z4nJ0elg8NLA0KhsAt/v0lHWr7nF44IJ/Oi/wG6yuitOvmjTQAAAABJRU5ErkJggg==";

const imageDataN14 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACcAAAAoCAYAAAB99ePgAAAEbklEQVRYw82Ye0xTVxzH2660SWnthCVrTeEfmXEDB+hEkRjA1AKJi2QuzsBm8AFBZqbYoEH+AUUUURMFymMBNSYkvrZpcIn8sWQBIw9dMelMiDzKoI6Up62bD/TU3/d6MagYKl7KPck3v55zfo/PfZ17biUS4dpyrVbrJLtCIsK2o+TIkedks8QIt/9CXR3gcsUId+iPhgbAFYoR7kT7rVuAOy5GOIu9sxNwFjHC1T4YGgJcrejIlApF3WO326MgKzq4gICAXwEHKzq4YIPhOuBgRQf3+eLFjYCDFR3cV8uWWQEHKzq4uNjYLsDBig7u63XrRgAHKzY22aaNG58BDhZ9oRJ/RtpB2sT/ls4gx8fp27YxwMGiP4McqBtCSiH9RFok0el0w3XnzrEqi4VlZmSwVdHRgxq1GstBMe8YSpJPt5KYd+/m4GDRn8ZfzudF/mLUQ93M9HSOAzzENSTx9/e3lp08yQbv3+eSQ/+NjXna29rY2dpaZs7OZokm06OgoKDblOgMyUwykRZMflgP5Odz8bDUj5w09ynJSMomnUYeyvc/8iK/leqg3kRtcJSfOsXAheB5pJ1KP7/6FVFRI3t27WL1V66wscHBV7AT6uvpYb9fvcqKi4rY9ykpLDIiYkipVGJdu/lzZSXnD0v9FowvjYx0ppIf/BHX1939Vk7UQT3URX2KqwcPz/Va+4i0nLSfyP+kI3xy/OhRZrNa30o6IdfwsOfunTvs4ego14dFH+PvirG1t7MTJSUsMSHhCepQvTxSFF/f66YlbSDVLAoJ6cc9cen8+dduAW8Ef8ThnkYe5CN9y+cXpOFpCiftpZ3H9VUrV7rzcnOZo7d3SlCMY55udDf5NyCOj5dKfND8SN99k5w8JRzGMc/7zUlLLjp4cEo4jGN+zl4LKpWqqd9u5+Ds9+6xtUYj6+ro4Pr99GRjfq7YotM2b+ZAHrlcHpPROI6nbk18/Dj6GMc8/HxOJpVKL/3V2srBWUpLAXGMnzpWUVbGjWMefr5mW5hgMo0DoLeri9HWvBNXeeJqfxIY2InLinlaK3FGF/oSrhQrPor/kJqKs5b0xnzS1rQ0bh5+8PcVWEBEeLgb99XNxkYmk8nqp3Ki8WstTU0MfvBHnC/gcmuqqrizEh8X95T6X7zDLzQ+NvYp/Gqqq3H2Zv0/FKXBYHDgvfnb5csoWDmNf9UvFy8y98gIvsociJ9NuC2HCwu5Lc6XS5a4qK+bxl8XFhrqgj/iED9bYLLA+fP/xku8uqIChQq8jCuoLC9nTocDT7VNIuAWfnJbvy8nB/s8T3Bw8AD1NV7GaWiDOTDqdHpyzGYc1HrBydRqdTM2m/w7c+d7hv+IuH9oTfRXqZqFZlublZnJ/u3rY4G0wFJf8Z7xCsQNUHzG9u04OKNgZHK5/FqHzcayaSsteflRMpOWgq04dsG0Bgr3SlsdE+O+3dzMaH/f9gE3tAzxLTduMFr/hPvwpk+3Fr1e30M/wz4wVdgCvd6u1WhavXF+ARY9KAT2gSA1AAAAAElFTkSuQmCC";

///////////////////////////////////////////////////////////////////////////////
// main script body
///////////////////////////////////////////////////////////////////////////////

const queryString = window.location.search;
const urlParams = new URLSearchParams(queryString);

// test
let test = false;
if(urlParams.has('test'))
{
	test = true;
}

// festival selection
let festivals = "ucl";
if(urlParams.has('festivals'))
{
	festivals = urlParams.get('festivals');
	if((festivals != "kemetic-reform")
		&& (festivals != "ucl"))
	{
		festivals = "ucl";
	}
}

// key date
let todayDate = new Date();
let wepRonpetDate = new Date();
if(festivals == "kemetic-reform")
{
	wepRonpetDate.setMonth(6);
	wepRonpetDate.setDate(18);
}
else
{
	wepRonpetDate.setMonth(7);
	wepRonpetDate.setDate(7);
}
if(wepRonpetDate > todayDate)
{
	wepRonpetDate.setFullYear(wepRonpetDate.getFullYear()-1);
}
if(urlParams.has('wep-ronpet'))
{
	wepRonpetDate = new Date(urlParams.get('wep-ronpet'));
}

let today = Math.floor((todayDate - wepRonpetDate) / 86400000) + 1;

// selected day
let selectedDay = (today >= 1) ? today : 1;
if(urlParams.has('selected-day'))
{
	selectedDay = parseInt(urlParams.get('selected-day'));
}

// location
let selectedLocation = 1;
let selectedLatitude = locations[0][0];
let selectedLongitude = locations[0][1];
// TODO: daylight savings etc.
let selectedTimezone = locations[0][2];
if(urlParams.has('selected-location'))
{
	selectedLocation = parseInt(urlParams.get('selected-location'));
	if(selectedLocation > 0)
	{
		selectedLatitude = locations[selectedLocation - 1][0];
		selectedLongitude = locations[selectedLocation - 1][1];
		selectedTimezone = locations[selectedLocation - 1][2];
	}
}

if(urlParams.has('selected-timezone'))
{
	selectedTimezone = parseFloat(urlParams.get('selected-timezone'));
}

if(selectedLocation == 0)
{
	if(urlParams.has('latitude'))
	{
		selectedLatitude = parseFloat(urlParams.get('latitude'));
	}
	if(urlParams.has('longitude'))
	{
		selectedLongitude = parseFloat(urlParams.get('longitude'));
	}
}

// set the values
for(const timezone of timezones)
{
	document.getElementById('timezone-choice').innerHTML +=
		'<option value="' + timezone[1] + '">' + timezone[0] + '</option>';
}

document.getElementById('location-choice').value = selectedLocation;
document.getElementById('timezone-choice').value = selectedTimezone;
document.getElementById('custom-latitude').value = selectedLatitude;
document.getElementById('custom-longitude').value = selectedLongitude;
document.getElementById('sopdet-visible-warning').style.display =
	(selectedLatitude >= sopdetMaxVisibleLatitude) ? 'block' : 'none';

// set the date in the picker
let datePicker = document.getElementById('wep-ronpet');
datePicker.value = wepRonpetDate.toISOString().substring(0, 10);

let gregorianDate = new Date(wepRonpetDate);
gregorianDate.setDate(gregorianDate.getDate() + (selectedDay - 1));
let gregorianYear = gregorianDate.getFullYear();
let gregorianMonth = gregorianDate.getMonth() + 1;
let gregorianDay = gregorianDate.getDate();

const seasonMonths =
[
	"I Akhet",
	"II Akhet",
	"III Akhet",
	"IV Akhet",
	"I Peret",
	"II Peret",
	"III Peret",
	"IV Peret",
	"I Shemu",
	"II Shemu",
	"III Shemu",
	"IV Shemu",
	"Intercalary"
];

const monthNamesDefault =
[
	"Tekhy",
	"Menhet",
	"Huwt-Her",
	"Ka Her Ka",
	"Sef Bedet",
	"Rekh-Wer",
	"Rekh-Nedes",
	"Renenutet",
	"Khonsu",
	"Henet Hetej",
	"Ipet Hemet",
	"Wep Ronpet",
	"Heryu Ronpet"
];

const monthNamesNew =
[
	"Djehuty",
	"Pan Ipet",
	"Huwt-Her",
	"Ka Her Ka",
	"Ta Ab",
	"Mekhyr",
	"Pan Imenhetepu",
	"Pan Renenutet",
	"Pan Khonsu",
	"Pan Inet",
	"Ipip",
	"Mesuwt Ra",
	"Heryu Ronpet"
];

const monthNamesGreek =
[
	"Thoth",
	"Phaophi",
	"Athur",
	"Khoiak",
	"Tub",
	"Mekhr",
	"Phamenoth",
	"Pharmouthi",
	"Pakhon",
	"Paoni",
	"Epiphi",
	"Mesore",
	"Epagomenai"
];

const monthNamesKemeticReform =
[
	"Djehutet",
	"Pa'en-Opet",
	"Athur",
	"Khoiak",
	"Tub",
	"Mekhr",
	"Phamenoth",
	"Pharmouthi",
	"Pakhon",
	"Paoni",
	"Epiphi",
	"Mesore",
	"Epagomenai"
];

// month style
let monthStyle = 0;
let monthNames = monthNamesDefault;
if(festivals == "kemetic-reform")
{
	monthNames = monthNamesKemeticReform;
}

if(urlParams.has('month-style'))
{
	monthStyle = urlParams.get('month-style');
	if(monthStyle == 1)
	{
		monthNames = monthNamesNew;
	}
	else if(monthStyle >= 2)
	{
		monthNames = monthNamesGreek;
	}
}
// set the dropdown for style of months
document.getElementById('month-names').value = monthStyle;

const festivalDataUCL = new Map(
[
	[1, "New Year - Opening of the Year - birthday of Ra-Horakhty (the sun-god)"],
	[15, "offerings to Hapy and Amun to secure a good flood (known from Dynasty 19 rock inscriptions at Gebel el-Silsila)"],
	[17, "Eve of the Wag festival"],
	[18, "Wag festival"],
	[19, "Wag and Thoth festival, according to the great festival list in the temple for Ramesses III at Medinet Habu"],
	[20, "Tekh (drunkenness)"],
	[22, "Great Procession (of Osiris)"],

	[30 + 15, "Start of Ipet festival as 11-day festivities for Amun in Luxor, according to the festival list of Thutmose III at Elephantine"],
	[30 + 18, "Local Elephantine festival of Khnum and Anuqet, according to the festival list of Thutmose III at Elephantine"],
	[30 + 19, "Start of Ipet festival as 27-day festivities for Amun in Luxor, according to the record of good deeds of Ramesses III (Papyrus Harris I), and great festival list in the temple for Ramesses III at Medinet Habu"],
	[30 + 27, "Start of 2-day local festival of Mont, according to the late Middle Kingdom (about 2025-1700 BC) accounts papyrus Boulaq 18 (referring to it as 'festival of Mont'; this may be not an annual festival, but one ceremony, perhaps at the consecration of a shrine)"],
	[30 + 28, "Local Elephantine festival of Satet and Anuqet, according to the festival list of Thutmose III at Elephantine"],

	[60 + 9, "Festival for Amun, according to the festival list of Thutmose III at Elephantine"],
	[60 + 30, "local Elephantine festival of Anuqet, according to the festival list of Thutmose III at Elephantine"],

	[90 + 1, "Festival for Hathor, according to the great festival list in the temple for Ramesses III at Medinet Habu"],
	[90 + 18, "start of the Khoiak ceremonies, start of the Khoiak ceremonies:"],
	[90 + 22, "Khoiak ceremony: Ploughing the Earth"],
	[90 + 26, "Khoiak ceremony: Sokar festival"],
	[90 + 30, "Khoiak ceremony: raising the Djed-pillar"],

	[120 + 1, "Festival for Hathor, according to the great festival list in the temple for Ramesses III at Medinet Habu"],
	[120 + 20, "Sailing of Wadjyt, according to an inscription for king Thutmose III at the temple of Mut, Karnak"],
	[120 + 29, "Sailing of Bast, according to an inscription for king Thutmose III at the temple of Mut, Karnak. Festival of Raising the Willow, according to the great festival list in the temple for Ramesses III at Medinet Habu"],
	[120 + 30, "sailing of Shesmet, according to an inscription for king Thutmose III at the temple of Mut, Karnak, according to a late New Kingdom Turin papyrus, the festival is the sailing of Mut lady of Isheru"],

	[150 + 1, "Sailing of Anubis"],
	[150 + 30, "A key date in a festival spanning several days, identified sometimes as 'Amun-in-the-festival-of-raising-heaven', and in some sources the day of bringing branches of the ished-tree (sacred tree of the sun-god at Iunu) and culminating on the next day, the first of the next month, with the ceremony of filling the sacred eye in Iunu; this is the halfway point of the year, ideal 'midwinter'"],

	[180 + 1, "Festival of Ptah (perhaps local to Thebes?), according to the journal for work on the king's tomb; day of return of the image of the deity in the festival 'Amun-in-the-festival-of-raising-heaven'"],
	[180 + 21, "Festival of king Amenhotep I in the valley (originally local to Thebes? month name indicates broader observation later?)"],
	[180 + 29, "start (?) of 4-day festival of king Amenhotep I for the Deir el-Medina workforce"],

	[210 + 4, "Festival of Bast, also recorded as the day of chewing onions for Bast"],
	[210 + 5, "Appearance of Bast in her boat, according to a Dynasty 26 statue (Louvre A88)"],
	[210 + 25, "Harvest offering to Renenutet, according to a depiction in Theban Tomb-chapel 38"],
	[210 + 27, "Granary offering to Renenutet, according to a depiction in Theban tomb-chapel 48"],

	[240 + 1, "Festival of Renenutet, also identified as the birthday of Nepri (personification of grain)"],
	[240 + 10, "Adoration of Anubis"],
	[240 + 11, "Festival of Min, a 4-day festival at the New Moon according to the great festival list in the temple for Ramesses III at Medinet Habu"],

	[300 + 15, "Offerings to Hapy and Amun to secure a good flood (known from Dynasty 19 rock inscriptions at Gebel el-Silsila)"],
	[300 + 30, "Eve of the Hathor festival at Thebes, according to stela for king Thutmose III, Cairo CG 34013"],

	[330 + 1, "Start of 2 day long festival, occasion not specified, according to late New Kingdom ostracon Deir el-Medina 209, verso, line 4"],
	[330 + 2, "Ipip festival, according to the journal for work on the king's tomb, Necropolis Journal pl.59, line 19"],
	[330 + 24, "Festival of Ptah (local?), according to a rough inscription on a Middle Kingdom pyramid"],
	[330 + 25, "Eve of start of year"],

	[360 + 1, "Birthday of Osiris"],
	[360 + 2, "Birthday of Horus"],
	[360 + 3, "Birthday of Seth"],
	[360 + 4, "Birthday of Isis"],
	[360 + 5, "Birthday of Nephthys"],
]);

const festivalDataKemeticReform = new Map(
[
	[1, "Upet Ronpet (Kemetic Reform New Year's); Mesopotamian month of Abu begins"],
	[4, "Poret Sopdut Observed"],
	[6, "First Quarter (First Denit)"],
	[10, "Decade 1"],
	[11, "Going Forth of Hathor; Feast of Tefnut at Esna"],
	[15, "Full Moon"],
	[18, "Wa'gy-Djehutet Observance"],
	[20, "Decade 2"],
	[22, "Last Quarter (Second Denit)"],
	[25, "Feast for Anubis in Denderah; Osiris Goes Forth"],
	[29, "Mesopotamian Festival of Ghosts (approximate)"],
	[30, "Decade 3; New Moon"],
	
	[30 + 1, "Feasts for Neith, Horus the Elder and Sobek, Lord of Ombos"],
	[30 + 5, "First Quarter (First Denit)"],
	[30 + 9, "Sailing of Horus of Behdet; Procession of Bastet, Mistress of Ankh-Tawy"],
]);

const festivalMap = new Map(
[
	[ "ucl", festivalDataUCL ],
	[ "kemetic-reform", festivalDataKemeticReform ]
]);

let sidebar = document.getElementsByClassName("sidebar")[0];
let monthsContainer = document.getElementsByClassName("months")[0];

// find the first month, and the container for the days
let firstMonth = monthsContainer.getElementsByClassName("month")[0];
let firstMonthDaysContainer = firstMonth.getElementsByClassName("days")[0];

// fix the first month's details
let firstMonthName = firstMonth.getElementsByClassName("month-name")[0];
firstMonthName.innerHTML = monthNames[0];

// find the first day
let firstDay = firstMonthDaysContainer.getElementsByClassName("day")[0];

// clone a copy for the intercalary days
let lastMonth = firstMonth.cloneNode(true);

// add the days
for(let i = 2; i <= 30; ++i)
{
	let clonedDay = firstDay.cloneNode(true);
	clonedDay.innerHTML = i.toString();
	firstMonthDaysContainer.appendChild(clonedDay);
}

// now clone the months
for(let i = 1; i < 12; ++i)
{
	let clonedMonth = firstMonth.cloneNode(true);
	let monthName = clonedMonth.getElementsByClassName("month-name")[0];
	let monthSeasonName =
		clonedMonth.getElementsByClassName("month-season-name")[0];
	monthSeasonName.innerHTML = seasonMonths[i];
	monthName.innerHTML = monthNames[i];
	monthsContainer.appendChild(clonedMonth);
}

// add the epogomeneal days...
let lastDaysContainer = lastMonth.getElementsByClassName("days")[0];
for(let i = 2; i <= 5; ++i)
{
	let clonedDay = firstDay.cloneNode(true);
	clonedDay.innerHTML = i.toString();
	lastDaysContainer.appendChild(clonedDay);
}

let intercalaryContainer = document.getElementsByClassName("intercalary")[0];
let monthName = lastMonth.getElementsByClassName("month-name")[0];
let monthSeasonName = lastMonth.getElementsByClassName("month-season-name")[0];
monthSeasonName.innerHTML = seasonMonths[12];
monthName.innerHTML = monthNames[12];
intercalaryContainer.appendChild(lastMonth);

// add onclick callbacks to each day, this relies on them being in order in
// the document
let allDays = document.getElementsByClassName("day");
let dayCounter = 1;
let firstDayUp = -1;
let firstDayDown = -1;
let secondDayUp = -1;
let sopdetRisingDay = null;
for (let day of allDays)
{
	const currentDay = dayCounter; // this is important...
	if(currentDay == today)
	{
		day.classList.add("today-date");
	}
	else if(festivalMap.get(festivals).has(currentDay))
	{
		day.classList.add("festival-date");
	}

	if((currentDay % 10) == 0)
	{
		day.classList.add("end-of-decan");
	}

	if(currentDay == selectedDay)
	{
		day.classList.add("selected-date");
	}

	// work out sunrise and sopdet altitude at that time.
	let startDate = new Date(wepRonpetDate);
	startDate.setDate(startDate.getDate() + (dayCounter - 1));
	const startJD = gregorianToJulianDay(startDate.getFullYear(), startDate.getMonth() + 1, startDate.getDate());
	const sunriseTime = calculateNextSunrise(startJD, selectedLatitude, selectedLongitude);
	const sopdetAltitude = evaluateSopdetLocalPosition(startJD + sunriseTime / 24, selectedLatitude, selectedLongitude)[0];
	if((firstDayUp < 0) && (sopdetAltitude > arcusVisionisSopdet))
	{
		// ... its up. this might eb the rising, might not be.
		firstDayUp = dayCounter;
		sopdetRisingDay = day;
	}

	if((firstDayDown < 0) && (sopdetAltitude < arcusVisionisSopdet))
	{
		// ... its up
		firstDayDown = dayCounter;
	}

	if((firstDayDown >= 0) && (secondDayUp < 0) && (sopdetAltitude > arcusVisionisSopdet))
	{
		// ... its up
		secondDayUp = dayCounter;
		// this is the rising
		sopdetRisingDay = day;
	}

	// having the const variable makes this work as expected.
	// there is a copy for each one, if we use dayCounter
	// naively we just end up referencing the value.
	day.onclick = function(){clickDay(currentDay);}
	++dayCounter;
}

let sopdetDayNumber = (secondDayUp < 0) ? firstDayUp : secondDayUp;
if(sopdetRisingDay != null)
{
	sopdetRisingDay.classList.add("sopdet-heliacal-rising-day");
}

function updateMonthStyle()
{
	monthStyle = document.getElementById('month-names').value;
	applyChanges();
}

function applyFestivalSelection()
{
	// TODO: ...
	applyChanges();
}

function applyLocationSelection()
{
	selectedLocation = document.getElementById('location-choice').value;
	selectedTimezone = locations[selectedLocation - 1][2];
	document.getElementById('timezone-choice').value = selectedTimezone;
	applyChanges();
}

function applyTimezoneSelection()
{
	selectedTimezone = document.getElementById('timezone-choice').value;
	applyChanges();
}

function applyLocation()
{
	selectedLocation = 0;
	selectedLatitude = document.getElementById('custom-latitude').value;
	selectedLongitude = document.getElementById('custom-longitude').value;
	applyChanges();
}

function updateLocationFromAPI(position)
{
	selectedLocation = 0;
	document.getElementById('custom-latitude').value = position.coords.latitude;
	document.getElementById('custom-longitude').value = position.coords.longitude;
	//selectedLatitude = position.coords.latitude;
	//selectedLongitude = position.coords.longitude;

	applyLocation();
}

function geolocate()
{
	if (navigator.geolocation)
	{
		navigator.geolocation.getCurrentPosition(updateLocationFromAPI);
	}
	else
	{
		alert("Geolocation API is not supported!");
	}
}

function applyChanges()
{
	let newLocation = window.location.pathname;

	if(datePicker.value != '2022-08-07')
	{
		newLocation+= "&wep-ronpet=" + datePicker.value;
	}

	if(((today >= 1) ? today : 1) != selectedDay)
	{
		newLocation += "&selected-day=" + selectedDay;
	}

	if(monthStyle != 0)
	{
		newLocation += "&month-style=" + monthStyle;
	}

	if(selectedLocation == 0)
	{
		newLocation += "&selected-location=0&latitude="
			+ selectedLatitude + "&longitude=" + selectedLongitude;
	}
	else if(selectedLocation != 1)
	{
		newLocation += "&selected-location=" + selectedLocation;
	}

	if(selectedTimezone != 0)
	{
		newLocation += "&selected-timezone=" + selectedTimezone;
	}
	
	if(festivals != "ucl")
	{
		newLocation += "&festivals=" + festivals;
	}

	window.location = newLocation.replace('&', '?');
}


var firstCall = true;
function clickDay(dayNumber)
{
	selectedDay = dayNumber;
	if(firstCall == false)
	{
		applyChanges();
		return;
	}

	firstCall = false;
	let month =  Math.floor((selectedDay - 1) / 30);
	let dayInMonth = ((selectedDay - 1) % 30) + 1;
	
	let timeOfDay = -selectedTimezone / 24.0;//1.0 / 48.0;
	const hourTime = 1.0 / 24.0;
	let startDate = new Date(wepRonpetDate);
	startDate.setDate(startDate.getDate() + (selectedDay - 1));
	const startJD = gregorianToJulianDay(startDate.getFullYear(), startDate.getMonth() + 1, startDate.getDate());
	const moonStartPhase = approximateMoonPhase(startJD + timeOfDay);
	const moonEndPhase = approximateMoonPhase(startJD + timeOfDay + 1);
	const newMoon = Math.floor(moonStartPhase) < Math.floor(moonEndPhase);
	const fullMoon = Math.floor(moonStartPhase + 0.5) < Math.floor(moonEndPhase + 0.5);
	let descriptionHTML = '<div class = "sidebar-title">' + seasonMonths[month] + ", " + dayInMonth.toString() + "</div>";

	if((selectedDay % 10) == 0)
	{
		descriptionHTML = '<div class="sidebar-end-of-decan">End of Decan</div>' + descriptionHTML;
	}

	if(selectedDay == sopdetDayNumber)
	{
		descriptionHTML = '<div class="sidebar-sopdet-day">Heliacal Rising of Sopdet (approximate)</div>' + descriptionHTML;
	}

	if(selectedDay == today)
	{
		descriptionHTML = '<div class="sidebar-today-title">Today</div>' + descriptionHTML;
	}
	
	if(newMoon)
	{
		descriptionHTML = '<div class="sidebar-moon-phase-title">New Moon</div>' + descriptionHTML;
	}
	else if(fullMoon)
	{
		descriptionHTML = '<div class="sidebar-moon-phase-title">Full Moon</div>' + descriptionHTML;
	}

	descriptionHTML += '<div class="sidebar-date-simple">'
		+ gregorianDay + "/" + gregorianMonth + "/" + gregorianYear
		+ " / day " + dayNumber.toString()
		+ " / JD " + gregorianToJulianDay(gregorianYear, gregorianMonth, gregorianDay) + "</div>";

	descriptionHTML += '<hr>';
	descriptionHTML += '<ul class="sidebar-day-segment-area"></ul><hr>';

	if(festivalMap.get(festivals).has(dayNumber))
	{
		descriptionHTML += "<div>" + festivalMap.get(festivals).get(dayNumber) + "</div>";
	}

	// temporary stuff for showing information useful for debugging.
	///*
	if(test)
	{
		descriptionHTML += "<br>TESTS:<br>";
		// TODO: report fails better
		//let fail = 0;
		//let count = 0;
		for(const testFunction of testFunctions)
		{
			const testResult = testFunction();
			descriptionHTML += '<p class="test-line">Testing &quot;' + testResult[0] + '&quot;<br>Result:' + testResult[1] + "</p>";
		}
	}
	//*/
	sidebar.innerHTML = descriptionHTML;

	// get the day segment container...
	let container = sidebar.getElementsByClassName("sidebar-day-segment-area")[0];

	// add the bars.
	for(let i = 0; i < 24; ++i)
	{
		const jdt = startJD + timeOfDay;
		timeOfDay += hourTime;

		const sunAltitude = evaluateSunCoordinates(jdt, selectedLatitude, selectedLongitude)[0];
		const moonCoords = evaluateMoonCoordinates(jdt, selectedLatitude, selectedLongitude);
		const moonAltitude = moonCoords[0];
		const sopdetAltitude = evaluateSopdetLocalPosition(jdt, selectedLatitude, selectedLongitude)[0];

		// add a suitable bar.
		let newHTML = container.innerHTML;
		newHTML += '<li class="sidebar-day-sgement" style="background: rgb(11,'

		const rawLevel = sunAltitude / (Math.PI * 0.5);
		const level = clamp(rawLevel, 0, 1);
		const sopdetLevel = clamp(sopdetAltitude / (Math.PI * 0.5), 0, 1);
		const moonLevel = clamp(moonAltitude / (Math.PI * 0.5), 0, 1);
		const colorLevel = clamp(3 * rawLevel + 0.5, 0, 1);
		// TODO: a better gradient, maybe some reds in it?
		newHTML += Math.floor(100 * colorLevel) + ',';
		newHTML += Math.floor(64 + 192 * colorLevel) + ')">';
		if(sopdetLevel > 0.0)
		{
			const newSopdetStyle = "top: " + (60 -sopdetLevel * 60) + "px;";
			newHTML += '<img class="sun-marker" src="' + imageDataN14 + '" style="' + newSopdetStyle + '">';
		}
		if(level > 0.0)
		{
			const newStyle = "top: " + (60 -level * 60) + "px;";
			newHTML += '<img class="sun-marker" src="' + imageDataN5 + '" style="' + newStyle + '">';
		}
		if(moonLevel > 0.0)
		{
			const newMoonStyle = "top: " + (60 -moonLevel * 60) + "px;";
			newHTML += '<img class="sun-marker" src="' + imageDataN10 + '" style="' + newMoonStyle + '">';
		}
		newHTML += i.toString() + 'h';
		newHTML += '</li>';
		container.innerHTML = newHTML;
	}

	let decSunrise = calculateNextSunrise(startJD, selectedLatitude, selectedLongitude);
	decSunrise += selectedTimezone;
	if(decSunrise < 0)
	{
		decSunrise += 24;
	}
	let decSunset = calculateNextSunset(startJD, selectedLatitude, selectedLongitude);
	decSunset += selectedTimezone;
	if(decSunset < 0)
	{
		decSunset += 24;
	}
	const sunriseHTML = '<div class="sunrise">Estimated sunrise time:'
		+ Math.floor(decSunrise) + "h "
		+ minutesFromDecimal(decSunrise) + "m "
		//+ secondsFromDecimal(decSunrise) + "s "
		+ "</div>";
	const sunsetHTML = '<div class="sunset">Estimated sunset time:'
		+ Math.floor(decSunset) + "h "
		+ minutesFromDecimal(decSunset) + "m "
		//+ secondsFromDecimal(decSunset) + "s "
		+ "</div>";

	sidebar.innerHTML = sidebar.innerHTML + sunriseHTML + sunsetHTML;
}

clickDay(selectedDay);

</script>

</body>
</html>
