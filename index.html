<html>

<head>
<!--
	the style is based on the simple example found on w3schools.com:

		https://www.w3schools.com/howto/howto_css_calendar.asp

	internal CSS is used for conveience of the user being able to download
	a single file and open it and "just work"

	if you want to override the style, copy paste this out to style .css and
	add the following line here, and comment out the style element

		<link rel="stylesheet" href="style.css">

	-->
<style>
ul
{
	list-style-type: none;
	padding-inline-start: 0px;
	margin-block-start: 0em;
	margin-block-end: 0em;
	justify-content: center;
}

body
{
	font-family: Verdana, sans-serif;
	font-size: 1.25vw;
}

.title
{
	font-weight: bold;
	font-size: 135%;
}

.test-line
{
	font-size: 75%;
}

.location-choice
{
	width: 10%;
}

.custom-latitude
{
	width: 10%;
}

.custom-longitude
{
	width: 10%;
}

.sopdet-visible-warning
{
	font-size: 85%;
	font-weight: bold;
	color: #a00;
}

.calendar-display
{
	width: 70%;
}

.sidebar
{
	width: 30%;
	height: 100%;
	position: fixed;
	top: 0;
	right: 0;
	padding-top: 40px;
	background-color: #ffffff;
}

.sidebar-today-title
{
	color: #00a;
}

.sidebar-end-of-decan
{
	color: #00a;
}

.sidebar-title
{
	font-size: 115%;
	font-weight: bold;
}

.sidebar-date-simple
{
	font-size: 95%;
	font-style: italic;
}

.months
{
	background: #3adcbc;
	padding: 0% 2%;
	text-align: center;
}

.intercalary
{
	background: #3adcbc;
	padding: 0% 2%;
	text-align: center;
}

.intercalary li
{
	display: inline-block;
	padding: 0.5% 0.5%;
	margin: 1% 1%;
	width: 20%;
	color: #333;
	background: #1abc9c;
	text-align: center;
}

.months li
{
	display: inline-block;
	padding: 0.5% 0.5%;
	margin: 1% 1%;
	width: 21.5%;
	color: #333;
	background: #1abc9c;
	text-align: center;
}

.month-name
{
	font-weight: bold;
	font-size: 95%;
	text-align: center;
}

.month-season-name
{
	font-style: italic;
	text-align: center;
	font-size: 85%;
	padding: 0.3% 0%;
	margin-bottom:1.5%;
}

.month hr
{
	margin-bottom:1%;
	margin-top:0.5%;
}

.days
{
	background: #ffffff;
	grid-template-columns: repeat(10, 1fr);
	display: grid;
	padding: 0;
	margin: 0;
	align-items: center;
	justify-content: center;
	justify-items: center;
	text-align: center;
	gap: 0;
}

.intercalary .days
{
	grid-template-columns: repeat(5, 1fr);
}

.days li
{
	display: inline-flex;
	color: #666;
	background: #ffffff;
	align-items: center;
	justify-content: center;
	text-align: center;
	font-size: 67%;
	border-width: 1.5px;
	border-style: solid;
	border-color: #ffffff;
	width: 100% !important;
}

.intercalary .days li
{
	grid-template-columns: repeat(5, 1fr);
	width: 66% !important;
}

.festival-date
{
	background: #6aeccc !important;
}

.today-date
{
	background: #ec6c6c !important;
	color: #000 !important;
}

.end-of-decan
{
	background: #f0bcbc !important;
	color: #777 !important;
}

.selected-date
{
	border-color: #59a !important;
}

@media (max-aspect-ratio: 5/3)
{
	body
	{
		font-size: 1.75vw;
	}

	.title
	{
		font-size: 150%;
	}

	.months li
	{
		width:29.5%;
	}
	
	.intercalary li
	{
		width: 30%;
	}
}

@media (max-aspect-ratio: 6/5)
{
	body
	{
		font-size: 3vw;
	}

	.title
	{
		font-size: 200%;
	}

	.location-choice
	{
		width: 15%;
	}

	.months li
	{
		width:46.5%;
	}
	
	.intercalary li
	{
		width: 50%;
	}

	.sidebar
	{
		width: 100%;
		height: 10%;
		padding-top: 40px;
		position: relative;
		background-color: #ffffff;
	}

	.calendar-display
	{
		width: 100%;
	}
}

@media (max-aspect-ratio: 5/6)
{
	body
	{
		font-size: 5vw;
	}

	.title
	{
		font-size: 111%;
	}

	.location-choice
	{
		width: 15%;
	}

	.months li
	{
		width:96.5%;
	}
	
	.intercalary li
	{
		width: 96.5%;
	}

	.sidebar
	{
		width: 100%;
		height: 10%;
		padding-top: 40px;
		position: relative;
		background-color: #ffffff;
	}

	.calendar-display
	{
		width: 100%;
	}
}


</style>

<title>Kemetic Festival Calendar</title>

</head>

<body>
<span class="title">Kemetic Festival Calendar</span>
<hr>
<div class="options">
	<label for="wep-ronpet">Wep Ronpet Date (Gregorian):</label>
	<input type="date" id="wep-ronpet" name="wep-ronpet">
	<button type="button" onclick='applyChanges();'>Change Date</button>
	<hr>
	<label for="month-names">Month Names:</label>
	<select name="month-names" id="month-names" onchange="updateMonthStyle()">
		<option value="0">Middle Kingdom</option>
		<option value="1">New Kingdom</option>
		<option value="2">Greek</option>
	</select>
	<hr>
	<label for="location-choice">Location:</label>
	<select class="location-choice" name="location-choice" id="location-choice" onchange="applyLocationSelection()">
		<option value="0">Custom</option>
		<option value="1">London, UK - Greenwich Observatory</option>
		<option value="2">Giza, Egypt - Great Pyramid</option>
	</select>
	<label for="custom-latitude"Latitude:</label>
	<input class="custom-latitude" name="custom-latitude" id="custom-latitude" type="text">
	<label for="custom-longitude"Longitude:</label>
	<input class="custom-longitude" name="custom-longitude" id="custom-longitude" type="text">
	<button type="button" onclick='applyLocation();'>Apply</button>
	<button type="button" onclick='geolocate();'>Use Current Location</button>
	<div class="sopdet-visible-warning" id="sopdet-visible-warning">
	WARNING: Sopdet never rises at this latitude!
	</div>
</div>
<hr>
<div>
	<div class="calendar-display">
		<ul class="months">
			<li class="month">
				<div class="month-name">Tekhy</div>
				<hr>
				<div class="month-season-name">I Akhet</div>
				<ul class="days">
					<li class="day">1</li></ul></li></ul> <!-- single line
							to work around a bug in browser rendering or HTML
							or something else that made a whitespace break things
							-->
		<ul class="intercalary">
		</ul>
	</div>
	<div class="sidebar">
	TODO: Sidebar information when selecting a date
	</div>
</div>
<script>

// the idea is to dynamically generate the html based on the query string
// when we press the button we refresh the page with a new query string.

// this is not necessarily the best way to do this, but allows copy-pasting
// the address-bar without introducing multiple points of failure

///////////////////////////////////////////////////////////////////////////////
// astronomical mathematics stuff
///////////////////////////////////////////////////////////////////////////////

function clamp(x, min, max)
{
	return Math.min(Math.max(x, min), max);
}

function accuracy(a, b)
{
	return Math.abs(a - b) / Math.abs(b);
}

function isWithinTolerance(a, b, proportion)
{
	return accuracy(a, b) < proportion;
}

// helper function to convert degrees to radians
function degreesToRadians(degrees)
{
	return (Math.PI / 180) * degrees;
}

// helper function to convert radians to degrees
function radiansToDegrees(radians)
{
	return (180 / Math.PI) * radians;
}

function RA(hours, minutes, seconds)
{
	// calculate the total right ascension in hours
	const totalRA = hours + (minutes / 60) + (seconds / 3600);

	// convert right ascension from hours to degrees
	return totalRA * 15;
}

function Dec(degrees, minutes, seconds)
{
	return degrees + (minutes / 60) + (seconds / 3600);
}

function displayTimeOfDaySeconds(seconds)
{
	return (Math.floor(seconds / 3600)) + "h" + (Math.floor(seconds / 60) % 60) + "m" + (Math.floor(seconds) % 60) + "s";
}
function displayAltAz(v)
{
	return [
		radiansToDegrees(v[0]),
		radiansToDegrees(v[1]) ];
}

function toJulianCenturiesSinceJ2000(julianDay)
{
	return (julianDay - 2451545.0) / 36525;
}

// evaluate a polynomial from a list of coefficients
function evaluateSeriesPolynomial(terms, t)
{
	let evaluation = terms[terms.length - 1];
	for (let i = (terms.length - 2); i >= 0; --i)
	{
		evaluation *= t;
		evaluation += terms[i];
	}
	return evaluation;
}

function gregorianToJulianDay(year, month, day)
{
	// adjust month and year for calculation purposes
	// we need february to be 'last' when calculating the days from months
	if (month <= 2)
	{
		month += 12;
		year -= 1;
	}

	// perform the Julian day calculation
	const centurySkippedLeapDays = Math.floor(year / 100);
	const fourCenturyLeapDays = Math.floor(centurySkippedLeapDays / 4);
	const leapDaysAdjustment = 2 - centurySkippedLeapDays + fourCenturyLeapDays;
	const daysFromYears = Math.floor(365.25 * (year + 4716));

	const daysFromMonths = Math.floor(30.6001 * (month + 1));
	// 30.6 creates the correct pattern of 30/31 day months
	// the extra 0.0001 looks like fine tuning to ensure correct rounding
	// together with the initial month and year adjustments this lets us work
	// out the days to add from the month number allowing us to handle the
	// special case of February by ignoring it.

	// evaluating f for the input values of month and looking at differences
	// shows a pattern alternating between 30 and 31, with 31 repeated.

	/*
		Month: 3, Result: 122, Difference: ???	// (no previous month)
		Month: 4, Result: 153, Difference: 31	// march
		Month: 5, Result: 183, Difference: 30	// april
		Month: 6, Result: 214, Difference: 31	// may
		Month: 7, Result: 244, Difference: 30	// june
		Month: 8, Result: 275, Difference: 31	// july
		Month: 9, Result: 306, Difference: 31	// august
		Month: 10, Result: 336, Difference: 30	// september
		Month: 11, Result: 367, Difference: 31	// october
		Month: 12, Result: 397, Difference: 30	// november
		Month: 13, Result: 428, Difference: 31	// december
		Month: 14, Result: 459, Difference: 31	// january
	*/

	return leapDaysAdjustment + day + daysFromYears + daysFromMonths - 1524.5;
}

function getGMSTSeconds(julianDay)
{
	// convert Julian Day to centuries since J2000.0
	const t = toJulianCenturiesSinceJ2000(julianDay);

	// terms for GMST expression
	const terms =
	[
		24110.54841,
		8640184.812866,
		0.093104,
		-6.2e-6
	];

	// evaluate GSMT0 using the terms
	// based on this expression for GMST in seconds
	// http://www.astro.sunysb.edu/metchev/AST443/times.html
	const jMidnight = julianDay - ((julianDay - 0.5) % 1.0);
	const tMidnight = toJulianCenturiesSinceJ2000(jMidnight);
	const gmst0 = evaluateSeriesPolynomial(terms, tMidnight);
	
	// this was found on stack exchange...
	const wTerms =
	[
		1.00273790935,
		5.9e-11
	];
	
	const wStar = evaluateSeriesPolynomial(wTerms, t);
	
	// get the time of day in seconds from midnight
	const utcSeconds = (julianDay - jMidnight) * 24 * 3600;
	
	// calculate mod number of seconds in the day...
	return (gmst0 + wStar * utcSeconds) % 86400;
}

// 10th order calculation of obliquity of the ecliptic
// claims to be valid over 10,000 years
function calculateMeanObliquityOfEcliptic(julianDay)
{
	// this is based on J. Meeus, Astronomical Algorithms, p. 135

	// convert Julian Day to centuries since J2000.0
	const t = toJulianCenturiesSinceJ2000(julianDay);

	// terms for the obliquity evaluation
	//const terms =
	//[
	//	84381.448, // J2000 obliquity
	//	-46.8150,
	//	-0.00059,
	//	0.001813
	//];
	const terms100 =
	[
		84381.448, // J2000 obliquity
		-4680.93,
		-1.55,
		1999.25,
		-51.38,
		-249.67,
		-39.05,
		7.12,
		27.87,
		5.79,
		2.45
	];

	//const arcseconds = evaluateSeriesPolynomial(terms, t);
	const arcseconds = evaluateSeriesPolynomial(terms100, clamp(t/100, -1, 1));
	const degrees = arcseconds / 3600.0;
	return degreesToRadians(degrees);
}

function solarMeanAnomaly(julianDay)
{
	const t = toJulianCenturiesSinceJ2000(julianDay);
	// mean anomaly of the Sun
	// (the polynomial is evaluated using Horner's scheme)
	return 357.5291092 + t * (35999.0502909 - t * (0.0001536 + t / 24490000.0));
}

function calculateNutationLongitude(julianDay)
{
	// convert Julian Day to centuries since J2000.0
	const t = toJulianCenturiesSinceJ2000(julianDay);

	// mean elongation of the Moon from the Sun
	// (the polynomial is evaluated using Horner's scheme)
	const l = 218.3164591 + t * (481267.88134236 - t * (0.0013268 + t * (1.0 / 538841.0 -  t / 65194000.0)));

	// mean anomaly of the Sun
	const m = solarMeanAnomaly(julianDay);

	// mean anomaly of the Moon
	const ms = 134.9634114 + t * (477198.8676313 + t * (0.008997 + t * (1.0 / 69699.0 - t / 14712000.0)));

	// moon's argument of latitude
	const f = 93.2720993 + t * (483202.0175273 - t * (0.0034029 - t * (1.0 / 3526000.0 + t / 863310000.0)));

	// longitude of the ascending node of the Moon's mean orbit on the ecliptic
	const omega = 125.044555 - t * (1934.1361849 + t * (0.0020762 + t * (1.0 / 467410.0 - t / 18720000.0)));

	// calculate the nutation in longitude
	const deltaPsi = (-17.20 * Math.sin(omega) - 1.32 * Math.sin(2 * l) - 0.23 * Math.sin(2 * m) + 0.21 * Math.sin(2 * omega)) / 3600.0;

	// Convert the nutation to radians
	return degreesToRadians(deltaPsi);
}

function RADecToCurrentEpoch(julianDay, raJ2000, decJ2000)
{
	// note these are only valid for J2000.0
	// convert Julian Day to centuries since J2000.0
	// from Meeus p 126
	const t = toJulianCenturiesSinceJ2000(julianDay);
	
	const zeta = degreesToRadians(
		t * (2306.2181 + t * (0.30188 + t * 0.017998)) / 3600);
	const z = degreesToRadians(
		t * (2306.2181 + t * (1.09468 + t * 0.018203)) / 3600);
	const theta = degreesToRadians(
		t * (2004.3109 + t * (0.42665 + t * 0.041833)) / 3600);
	
	const cosDecJ2000 = Math.cos(decJ2000);
	const sinDecJ2000 = Math.sin(decJ2000);
	const cosAdjustedRA = Math.cos(raJ2000 + zeta);
	const sinAdjustedRA = Math.sin(raJ2000 + zeta);
	const cosTheta = Math.cos(theta);
	const sinTheta = Math.sin(theta);
	const A = cosDecJ2000 * sinAdjustedRA;
	const B = cosTheta * cosDecJ2000 * cosAdjustedRA - sinTheta * sinDecJ2000;
	const C = sinTheta * cosDecJ2000 * cosAdjustedRA + cosTheta * sinDecJ2000;
	
	const ra = Math.atan2(A, B) + z;
	const dec = Math.asin(C);
	return [ra, dec];
}

// this produces altitude an azimuth with corrections around J2000.0
function calculateAltitudeAzimuth(
	julianDay, raJ2000, decJ2000, latitude, longitude)
{
	const obliquity = calculateMeanObliquityOfEcliptic(julianDay);
	const nutation = calculateNutationLongitude(julianDay);

	// convert latitude and longitude to radians
	const latRad = degreesToRadians(latitude);
	const lonRad = degreesToRadians(longitude);

	// convert right ascension (RA) and declination (Dec) to radians
	const raJ2000Rad = degreesToRadians(raJ2000);
	const decJ2000Rad = degreesToRadians(decJ2000);
	
	// then precession to the current epoch...
	const raDec = RADecToCurrentEpoch(julianDay, raJ2000Rad, decJ2000Rad);
	const raRad = raDec[0];
	const decRad = raDec[1];

	// calculate the Greenwich mean sidereal time (GMST)
	// put it into hours...
	let gmst = (getGMSTSeconds(julianDay) / 3600) % 24 ;
	if(gmst < 0)
	{
		gmst += 24;
	}

	// then degrees... then radians
	gmst = degreesToRadians(15 * gmst);

	// apply nutation and obliquity correction to right ascension and declination
	const raRadCorrected = raRad + nutation;
	const decRadCorrected = decRad + obliquity
		- degreesToRadians(84381.448/3600); // change since J2000.0

	// calculate the hour angle
	const hourAngleRad = gmst - lonRad - raRadCorrected;

	// calculate the sine and cosine of the latitude and declination
	const sinLat = Math.sin(latRad);
	const cosLat = Math.cos(latRad);
	const sinDec = Math.sin(decRadCorrected);
	const cosDec = Math.cos(decRadCorrected);
	const tanDec = sinDec / cosDec;
	// ... and the hour angle
	const sinH = Math.sin(hourAngleRad);
	const cosH = Math.cos(hourAngleRad);

	// calculate the altitude and azimuth
	const altitude = Math.asin(
		sinLat * sinDec + cosLat * cosDec * cosH);
	let azimuth = Math.atan2(
		sinH,
		cosH * sinLat - tanDec * cosLat);
	if(azimuth < 0)
	{
		azimuth += 2 * Math.PI;
	}
	// SE - NOTE: we leave it in radians
	// the parameters being in degrees are just a convenience
	return [ altitude, azimuth ];
}

// calculate sopdet location for a given time and place
function evaluateSopdetLocalPosition(julianDay, latitude, longitude)
{
	// TODO: take distance and proper motion into accounts and model
	// the 3d motion of the star to generate RA and Dec for the
	// correct epoch
	const sopdetCelestialCoordinatesJ2000 =
	[
		RA(6, 45, 8.91728),
		Dec(-16, 42, 58.0171)
	];

	return calculateAltitudeAzimuth(
		julianDay,
		sopdetCelestialCoordinatesJ2000[0],
		sopdetCelestialCoordinatesJ2000[1],
		latitude, longitude);
}

function calculateSunRaDec(julianDay)
{
	return [0, 0];
}

// calculate position of Sun in the for a given time and place
function evaluateSunCoordinates(julianDay, latitude, longitude)
{
	let sunRADec = calculateSunRaDec(julianDay);
	return calculateAltitudeAzimuth(
		julianDay,
		sunRADec[0],
		sunRADec[1],
		latitude,
		longitude);
}

const sopdetMaxVisibleLatitude = 90 + Dec(-16, 42, 58.0171);
const locations =
[
	[51.4769, -0.0005], // Greenwich Observatory
	[29.9792, 31.1342], // Great Pyramid of Giza
];

function calculateNextSunrise(julianDay, latitude, longitude)
{
	// try to find a point where the sun is below the horizon to start...
	// work out its position at each hour for the next 24 hours to start.
	// it is simple minded but allows a binary search to complete the problem.
	// ... in most cases
	let hoursSunAltAz = new Array(24);
	hoursSunAltAz[0] = evaluateSunCoordinates(julianDay, latitude, longitude);
	let lastSunAlt = hoursSunAltAz[0][0];
	let riseHour = -1;
	let timeStep = 1.0 / 24.0;
	for(let i = 1; i < 96; ++i)
	{
		hoursSunAltAz[i] = evaluateSunCoordinates(
			julianDay + i*timeStep, latitude, longitude);
		if((riseHour < 0) && (hoursSunAltAz[i][0] > 0.0) && (lastSunAlt < 0.0))
		{
			riseHour = i;
			break;
		}
		lastSunAlt = hoursSunAltAz[i][0];
	}
	return [ riseHour, hoursSunAltAz ];
}

///////////////////////////////////////////////////////////////////////////////
// tests for astronomical algorithms
///////////////////////////////////////////////////////////////////////////////

const passedHtml = '<span style="color:blue">PASSED</span>';
const failedHtml = '<span style="color:red">FAILED</span>';

function testJulianDay01Jan2019()
{
	const testValue = gregorianToJulianDay(2019,1,1);
	return [ "Julian day number for 2019-1-1 = 2458484.5",
		(testValue == 2458484.5)
			? passedHtml : (failedHtml + ", expected 2458484.5, got " + testValue)];
}

function testGMST01Jan20190800()
{
	// checked here, as other calculators seemed to make errors:
	// https://phpsciencelabs.com/sidereal-time-calculator/index.php
	// note it only goes to 3dp...
	const testValue = getGMSTSeconds(2458484.5 + (8 / 24));
	return [ "GMST at 2019-1-1 08:00:00",
		isWithinTolerance(testValue, 52965.379, 0.001)
			? (passedHtml + ", test error = " + accuracy(testValue, 52965.379)*100 + "%")
			: (failedHtml + ", expected 52965.37916293584, got " + testValue)];
}

function testMeanObliquity2458850()
{
	const testValue = radiansToDegrees(calculateMeanObliquityOfEcliptic(2458850));
	const checkValue = 84372.086416 / 3600;
	return [ "Mean Obliquity of the Ecliptic @ JD 2458850",
		isWithinTolerance(testValue, checkValue, 0.001)
			? (passedHtml + ", test error = " + accuracy(testValue, checkValue)*100 + "%")
			: (failedHtml + ", expected " + checkValue + ", got " + testValue)];
}

function testMeanObliquity17214255()
{
	const testValue = radiansToDegrees(calculateMeanObliquityOfEcliptic(1721425.5));
	const checkValue = 23.6947529287;
	return [ "Mean Obliquity of the Ecliptic @ JD 1721425.5",
		isWithinTolerance(testValue, checkValue, 0.001)
			? (passedHtml + ", test error = " + accuracy(testValue, checkValue)*100 + "%")
			: (failedHtml + ", expected " + checkValue + ", got " + testValue)];
}

function testRADecAltAz1()
{
	const testValue = radiansToDegrees(
		calculateAltitudeAzimuth(
			2459349.5, RA(5,0,0), 50, 50, 50)[0]);
	const checkValue = Dec(27, 21, 22);
	return [ "RA/Dec to Alt/Az @ JD 2459349.5",
		isWithinTolerance(testValue, checkValue, 0.01)
			? (passedHtml + ", test error = " + accuracy(testValue, checkValue)*100 + "%")
			: (failedHtml + ", expected " + checkValue + ", got " + testValue)];
}

function testRADecAltAz2()
{
	const testValue = radiansToDegrees(
		calculateAltitudeAzimuth(
			2459349.5, RA(5,0,0), 50, 50, 50)[1]);
	const checkValue = Dec(316-180, 29, 14.60);
	return [ "RA/Dec to Alt/Az @ JD 2459349.5",
		isWithinTolerance(testValue, checkValue, 0.01)
			? (passedHtml + ", test error = " + accuracy(testValue, checkValue)*100 + "%")
			: (failedHtml + ", expected " + checkValue + ", got " + testValue)];
}

function testRADecAltAz3()
{
	// worked example from Meeus...
	const date = gregorianToJulianDay(1987, 4, 10) + 19/24 + 21/(24*60);
	const testValue = radiansToDegrees(
		calculateAltitudeAzimuth(
			gregorianToJulianDay(1987, 4, 10) + 19/24 + 21/(24*60),
			RA(23,9,16.641), Dec(-6,43,11.61),
			Dec(38,55,17), Dec(77, 3, 56))[0]);
	const checkValue = Dec(15.1249,0,0); // book value
	// value from reference calculator at https://astrogreg.com/convert_ra_dec_to_alt_az.html
	//+016° 06' 39.39"
		//Dec(16, 6, 39.39);
	return [ "RA/Dec to Alt/Az @ JD " + date,
		isWithinTolerance(testValue, checkValue, 0.01)
			? (passedHtml + ", test error = " + accuracy(testValue, checkValue)*100 + "%")
			: (failedHtml + ", expected " + checkValue + ", got " + testValue)];
}

const testFunctions =
[
	testJulianDay01Jan2019,
	testGMST01Jan20190800,
	testMeanObliquity2458850,
	testMeanObliquity17214255,
	testRADecAltAz1,
	testRADecAltAz2,
	//testRADecAltAz3,
];

///////////////////////////////////////////////////////////////////////////////
// main script body
///////////////////////////////////////////////////////////////////////////////

const queryString = window.location.search;
const urlParams = new URLSearchParams(queryString);

// test
let test = false;
if(urlParams.has('test'))
{
	test = true;
}

// key date
let todayDate = new Date();
let wepRonpetDate = new Date();
wepRonpetDate.setMonth(7);
wepRonpetDate.setDate(7);
if(wepRonpetDate > todayDate)
{
	wepRonpetDate.setFullYear(wepRonpetDate.getFullYear()-1);
}
if(urlParams.has('wep-ronpet'))
{
	wepRonpetDate = new Date(urlParams.get('wep-ronpet'));
}

let today = Math.floor((todayDate - wepRonpetDate) / 86400000) + 1;

// selected day
let selectedDay = (today >= 1) ? today : 1;
if(urlParams.has('selected-day'))
{
	selectedDay = parseInt(urlParams.get('selected-day'));
}

// location
let selectedLocation = 1;
let selectedLatitude = locations[0][0];
let selectedLongitude = locations[0][1];
if(urlParams.has('selected-location'))
{
	selectedLocation = parseInt(urlParams.get('selected-location'));
	if(selectedLocation > 0)
	{
		selectedLatitude = locations[selectedLocation - 1][0];
		selectedLongitude = locations[selectedLocation - 1][1];
	}
}

if(selectedLocation == 0)
{
	if(urlParams.has('latitude'))
	{
		selectedLatitude = parseInt(urlParams.get('latitude'));
	}
	if(urlParams.has('longitude'))
	{
		selectedLongitude = parseInt(urlParams.get('longitude'));
	}
}

// set the values
document.getElementById('location-choice').value = selectedLocation;
document.getElementById('custom-latitude').value = selectedLatitude;
document.getElementById('custom-longitude').value = selectedLongitude;
document.getElementById('sopdet-visible-warning').style.display =
	(selectedLatitude >= sopdetMaxVisibleLatitude) ? 'block' : 'none';

// set the date in the picker
let datePicker = document.getElementById('wep-ronpet');
datePicker.value = wepRonpetDate.toISOString().substring(0, 10);

let gregorianDate = new Date(wepRonpetDate);
gregorianDate.setDate(gregorianDate.getDate() + (selectedDay - 1));
let gregorianYear = gregorianDate.getFullYear();
let gregorianMonth = gregorianDate.getMonth() + 1;
let gregorianDay = gregorianDate.getDate();

const seasonMonths =
[
	"I Akhet",
	"II Akhet",
	"III Akhet",
	"IV Akhet",
	"I Peret",
	"II Peret",
	"III Peret",
	"IV Peret",
	"I Shemu",
	"II Shemu",
	"III Shemu",
	"IV Shemu",
	"Intercalary"
];

const monthNamesDefault =
[
	"Tekhy",
	"Menhet",
	"Huwt-Her",
	"Ka Her Ka",
	"Sef Bedet",
	"Rekh-Wer",
	"Rekh-Nedes",
	"Renenutet",
	"Khonsu",
	"Henet Hetej",
	"Ipet Hemet",
	"Wep Ronpet",
	"Heryu Ronpet"
];

const monthNamesNew =
[
	"Djehuty",
	"Pan Ipet",
	"Huwt-Her",
	"Ka Her Ka",
	"Ta Ab",
	"Mekhyr",
	"Pan Imenhetepu",
	"Pan Renenutet",
	"Pan Khonsu",
	"Pan Inet",
	"Ipip",
	"Mesuwt Ra",
	"Heryu Ronpet"
];


const monthNamesGreek =
[
	"Thoth",
	"Phaophi",
	"Athur",
	"Khoiak",
	"Tubí",
	"Mekhír",
	"Phamenoth",
	"Pharmouthi",
	"Pakhon",
	"Paoni",
	"Epiphi",
	"Mesore",
	"Epagomenai"
];

// month style
let monthStyle = 0;
let monthNames = monthNamesDefault;
if(urlParams.has('month-style'))
{
	monthStyle = urlParams.get('month-style');
	if(monthStyle == 1)
	{
		monthNames = monthNamesNew;
	}
	else if(monthStyle >= 2)
	{
		monthNames = monthNamesGreek;
	}
}
// set the dropdown for style of months
document.getElementById('month-names').value = monthStyle;

const festivalDataUCL = new Map(
[
	[1, "New Year - Opening of the Year - birthday of Ra-Horakhty (the sun-god)"],
	[15, "offerings to Hapy and Amun to secure a good flood (known from Dynasty 19 rock inscriptions at Gebel el-Silsila)"],
	[17, "Eve of the Wag festival"],
	[18, "Wag festival"],
	[19, "Wag and Thoth festival, according to the great festival list in the temple for Ramesses III at Medinet Habu"],
	[20, "Tekh (drunkenness)"],
	[22, "Great Procession (of Osiris)"],

	[30 + 15, "Start of Ipet festival as 11-day festivities for Amun in Luxor, according to the festival list of Thutmose III at Elephantine"],
	[30 + 18, "Local Elephantine festival of Khnum and Anuqet, according to the festival list of Thutmose III at Elephantine"],
	[30 + 19, "Start of Ipet festival as 27-day festivities for Amun in Luxor, according to the record of good deeds of Ramesses III (Papyrus Harris I), and great festival list in the temple for Ramesses III at Medinet Habu"],
	[30 + 27, "Start of 2-day local festival of Mont, according to the late Middle Kingdom (about 2025-1700 BC) accounts papyrus Boulaq 18 (referring to it as 'festival of Mont'; this may be not an annual festival, but one ceremony, perhaps at the consecration of a shrine)"],
	[30 + 28, "Local Elephantine festival of Satet and Anuqet, according to the festival list of Thutmose III at Elephantine"],

	[60 + 9, "Festival for Amun, according to the festival list of Thutmose III at Elephantine"],
	[60 + 30, "local Elephantine festival of Anuqet, according to the festival list of Thutmose III at Elephantine"],

	[90 + 1, "Festival for Hathor, according to the great festival list in the temple for Ramesses III at Medinet Habu"],
	[90 + 18, "start of the Khoiak ceremonies, start of the Khoiak ceremonies:"],
	[90 + 22, "Khoiak ceremony: Ploughing the Earth"],
	[90 + 26, "Khoiak ceremony: Sokar festival"],
	[90 + 30, "Khoiak ceremony: raising the Djed-pillar"],

	[120 + 1, "Festival for Hathor, according to the great festival list in the temple for Ramesses III at Medinet Habu"],
	[120 + 20, "Sailing of Wadjyt, according to an inscription for king Thutmose III at the temple of Mut, Karnak"],
	[120 + 29, "Sailing of Bast, according to an inscription for king Thutmose III at the temple of Mut, Karnak. Festival of Raising the Willow, according to the great festival list in the temple for Ramesses III at Medinet Habu"],
	[120 + 30, "sailing of Shesmet, according to an inscription for king Thutmose III at the temple of Mut, Karnak, according to a late New Kingdom Turin papyrus, the festival is the sailing of Mut lady of Isheru"],

	[150 + 1, "Sailing of Anubis"],
	[150 + 30, "A key date in a festival spanning several days, identified sometimes as 'Amun-in-the-festival-of-raising-heaven', and in some sources the day of bringing branches of the ished-tree (sacred tree of the sun-god at Iunu) and culminating on the next day, the first of the next month, with the ceremony of filling the sacred eye in Iunu; this is the halfway point of the year, ideal 'midwinter'"],

	[180 + 1, "Festival of Ptah (perhaps local to Thebes?), according to the journal for work on the king's tomb; day of return of the image of the deity in the festival 'Amun-in-the-festival-of-raising-heaven'"],
	[180 + 21, "Festival of king Amenhotep I in the valley (originally local to Thebes? month name indicates broader observation later?)"],
	[180 + 29, "start (?) of 4-day festival of king Amenhotep I for the Deir el-Medina workforce"],

	[210 + 4, "Festival of Bast, also recorded as the day of chewing onions for Bast"],
	[210 + 5, "Appearance of Bast in her boat, according to a Dynasty 26 statue (Louvre A88)"],
	[210 + 25, "Harvest offering to Renenutet, according to a depiction in Theban Tomb-chapel 38"],
	[210 + 27, "Granary offering to Renenutet, according to a depiction in Theban tomb-chapel 48"],

	[240 + 1, "Festival of Renenutet, also identified as the birthday of Nepri (personification of grain)"],
	[240 + 10, "Adoration of Anubis"],
	[240 + 11, "Festival of Min, a 4-day festival at the New Moon according to the great festival list in the temple for Ramesses III at Medinet Habu"],

	[300 + 15, "Offerings to Hapy and Amun to secure a good flood (known from Dynasty 19 rock inscriptions at Gebel el-Silsila)"],
	[300 + 30, "Eve of the Hathor festival at Thebes, according to stela for king Thutmose III, Cairo CG 34013"],

	[330 + 1, "Start of 2 day long festival, occasion not specified, according to late New Kingdom ostracon Deir el-Medina 209, verso, line 4"],
	[330 + 2, "Ipip festival, according to the journal for work on the king's tomb, Necropolis Journal pl.59, line 19"],
	[330 + 24, "Festival of Ptah (local?), according to a rough inscription on a Middle Kingdom pyramid"],
	[330 + 25, "Eve of start of year"],

	[360 + 1, "Birthday of Osiris"],
	[360 + 2, "Birthday of Horus"],
	[360 + 3, "Birthday of Seth"],
	[360 + 4, "Birthday of Isis"],
	[360 + 5, "Birthday of Nephthys"],
]);

let sidebar = document.getElementsByClassName("sidebar")[0];
let monthsContainer = document.getElementsByClassName("months")[0];

// find the first month, and the container for the days
let firstMonth = monthsContainer.getElementsByClassName("month")[0];
let firstMonthDaysContainer = firstMonth.getElementsByClassName("days")[0];

// fix the first month's details
let firstMonthName = firstMonth.getElementsByClassName("month-name")[0];
firstMonthName.innerHTML = monthNames[0];

// find the first day
let firstDay = firstMonthDaysContainer.getElementsByClassName("day")[0];

// clone a copy for the intercalary days
let lastMonth = firstMonth.cloneNode(true);

// add the days
for(let i = 2; i <= 30; ++i)
{
	let clonedDay = firstDay.cloneNode(true);
	clonedDay.innerHTML = i.toString();
	firstMonthDaysContainer.appendChild(clonedDay);
}

// now clone the months
for(let i = 1; i < 12; ++i)
{
	let clonedMonth = firstMonth.cloneNode(true);
	let monthName = clonedMonth.getElementsByClassName("month-name")[0];
	let monthSeasonName =
		clonedMonth.getElementsByClassName("month-season-name")[0];
	monthSeasonName.innerHTML = seasonMonths[i];
	monthName.innerHTML = monthNames[i];
	monthsContainer.appendChild(clonedMonth);
}

// add the epogomeneal days...
let lastDaysContainer = lastMonth.getElementsByClassName("days")[0];
for(let i = 2; i <= 5; ++i)
{
	let clonedDay = firstDay.cloneNode(true);
	clonedDay.innerHTML = i.toString();
	lastDaysContainer.appendChild(clonedDay);
}

let intercalaryContainer = document.getElementsByClassName("intercalary")[0];
let monthName = lastMonth.getElementsByClassName("month-name")[0];
let monthSeasonName = lastMonth.getElementsByClassName("month-season-name")[0];
monthSeasonName.innerHTML = seasonMonths[12];
monthName.innerHTML = monthNames[12];
intercalaryContainer.appendChild(lastMonth);

// add onclick callbacks to each day, this relies on them being in order in
// the document
let allDays = document.getElementsByClassName("day");
let dayCounter = 1;
for (let day of allDays)
{
	const currentDay = dayCounter; // this is important...
	if(currentDay == today)
	{
		day.classList.add("today-date");
	}
	else if(festivalDataUCL.has(currentDay))
	{
		day.classList.add("festival-date");
	}

	if((currentDay % 10) == 0)
	{
		day.classList.add("end-of-decan");
	}

	if(currentDay == selectedDay)
	{
		day.classList.add("selected-date");
	}

	// having the const variable makes this work as expected.
	// there is a copy for each one, if we use dayCounter
	// naively we just end up referencing the value.
	day.onclick = function(){clickDay(currentDay);}
	++dayCounter;
}

function updateMonthStyle()
{
	monthStyle = document.getElementById('month-names').value;
	applyChanges();
}

function applyLocationSelection()
{
	selectedLocation = document.getElementById('location-choice').value;
	applyChanges();
}

function applyLocation()
{
	selectedLocation = 0;
	selectedLatitude = document.getElementById('custom-latitude').value;
	selectedLongitude = document.getElementById('custom-longitude').value;
	applyChanges();
}

function updateLocationFromAPI(position)
{
	selectedLocation = 0;
	document.getElementById('custom-latitude').value = position.coords.latitude;
	document.getElementById('custom-longitude').value = position.coords.longitude;
	//selectedLatitude = position.coords.latitude;
	//selectedLongitude = position.coords.longitude;

	applyLocation();
}

function geolocate()
{
	if (navigator.geolocation)
	{
		navigator.geolocation.getCurrentPosition(updateLocationFromAPI);
	}
	else
	{
		alert("Geolocation API is not supported!");
	}
}

function applyChanges()
{
	let newLocation = window.location.pathname;
	
	if(datePicker.value != '2022-08-07')
	{
		newLocation+= "&wep-ronpet=" + datePicker.value;
	}
	
	if(((today >= 1) ? today : 1) != selectedDay)
	{
		newLocation += "&selected-day=" + selectedDay;
	}

	if(monthStyle != 0)
	{
		newLocation += "&month-style=" + monthStyle;
	}

	if(selectedLocation == 0)
	{
		newLocation += "&selected-location=0&latitude="
			+ selectedLatitude + "&latitude=" + selectedLongitude;
	}
	else if(selectedLocation != 1)
	{
		newLocation += "&selected-location=" + selectedLocation;
	}

	window.location = newLocation.replace('&', '?');
}


var firstCall = true;
function clickDay(dayNumber)
{
	selectedDay = dayNumber;
	if(firstCall == false)
	{
		applyChanges();
		return;
	}

	firstCall = false;
	let month =  Math.floor((selectedDay - 1) / 30);
	let dayInMonth = ((selectedDay - 1) % 30) + 1;
	let descriptionHTML = '<div class = "sidebar-title">' + seasonMonths[month] + ", " + dayInMonth.toString() + "</div>";

	if((selectedDay % 10) == 0)
	{
		descriptionHTML = '<div class="sidebar-end-of-decan">End of Decan</div>' + descriptionHTML;
	}

	if(selectedDay == today)
	{
		descriptionHTML = '<div class="sidebar-today-title">Today</div>' + descriptionHTML;
	}

	descriptionHTML += '<div class="sidebar-date-simple">'
		+ gregorianDay + "/" + gregorianMonth + "/" + gregorianYear
		+ " / day " + dayNumber.toString()
		+ " / JD " + gregorianToJulianDay(gregorianYear, gregorianMonth, gregorianDay) + "</div>";
	if(festivalDataUCL.has(dayNumber))
	{
		descriptionHTML += "<hr><div>" + festivalDataUCL.get(dayNumber) + "</div>";
	}
	
	// temporary stuff for showing information useful for debugging.
	///*
	if(test)
	{
		descriptionHTML += "<br>TESTS:<br>";
		for(const testFunction of testFunctions)
		{
			const testResult = testFunction();
			descriptionHTML += '<p class="test-line">Testing &quot;' + testResult[0] + '&quot; Result:' + testResult[1] + "</p>";
		}
		descriptionHTML += "<br><br>DEBUG:<br>";
		descriptionHTML += JSON.stringify(debuggings, null, 4);
	}
	//*/
	sidebar.innerHTML = descriptionHTML;
}

// debugs
let debugsGregorianDate = new Date(wepRonpetDate);
debugsGregorianDate.setDate(debugsGregorianDate.getDate() + (selectedDay - 1));
let foob = gregorianToJulianDay(debugsGregorianDate.getFullYear(), debugsGregorianDate.getMonth() + 1, debugsGregorianDate.getDate());
let debuggings = calculateNextSunrise(foob - 0.5, selectedLatitude, selectedLongitude);

clickDay(selectedDay);

</script>

</body>
</html>
